*** WARNING *** DO NOT MODIFY THIS FILE IN ANY WAY! *** WARNING ***
FUNCTION NormalizeString(cString)
*++
* Remove space and punctuation from a string, and convert to uppercase.
* Typically used to prepare strings for comparison.
*--
  RETURN PADR(UPPER(CHRTRAN(m.cString, CHR(34) + " ~!@#$%^&()_+|-`=\:;,./<>'", '')), LEN(m.cString))
ENDFUNC


FUNCTION SoundsLike(cInString)
*++
*>>Return a phonetic representation of a character string.
*--
LOCAL ix, ch, cLastCh, nStart, lHasDigit, cTempBuffer, cResult, cWord

  m.cTempBuffer = ''
  FOR ix = 1 TO LEN(TRIM(m.cInString)) + 1
    m.ch = IIF(m.ix > LEN(m.cInString), '.', SUBSTR(m.cInString, m.ix, 1))
    IF ISALPHA(m.ch) OR ISDIGIT(m.ch) OR m.ch $ '*?'   && allow wildcards in words
      IF EMPTY(m.nStart)   && Start of a new word
        m.nStart = m.ix
        STORE .F. TO m.lHasDigit
      ENDIF
      m.lHasDigit = m.lHasDigit OR ISDIGIT(m.ch)
    ELSE
      * Came upon a word break, process any word we have been building.
      IF NOT EMPTY(m.nStart)  && If we have a word...
        m.cWord = SUBSTR(m.cInString, m.nStart, m.ix-m.nStart)
        IF NOT m.lHasDigit
          * We have isolated a word that needs analysis
          m.cWord = LOWER(m.cWord)
          m.cWord = STRTRAN(m.cWord, 'ci', 'Se')  && Placeholder vowel removed later
          m.cWord = STRTRAN(m.cWord, 'ce', 'Se')
          m.cWord = STRTRAN(m.cWord, 'cy', 'Se')
          m.cWord = STRTRAN(m.cWord, 'cae', 'Se')
          m.cWord = STRTRAN(m.cWord, 'cz', 'S')
          m.cWord = STRTRAN(m.cWord, 'tch', 'S')
          m.cWord = STRTRAN(m.cWord, 'wr', 'R')
          m.cWord = STRTRAN(m.cWord, 'ph', 'F')
          m.cWord = STRTRAN(m.cWord, 'qu', 'KW')
          m.cWord = STRTRAN(m.cWord, 'ge', 'Je')
          m.cWord = STRTRAN(m.cWord, 'gy', 'Je')
          m.cWord = STRTRAN(m.cWord, 'gi', 'Je')
          m.cWord = STRTRAN(m.cWord, 'gn', 'N')
          m.cWord = STRTRAN(m.cWord, 'kn', 'N')
          m.cWord = STRTRAN(m.cWord, 'dn', 'N')
          m.cWord = CHRTRAN(m.cWord, 'cvmdzp', 'KFNTSB')

          * Special translations for leading character of a word.
          DO CASE
            CASE LEFT(m.cWord, 1) = 'x'
              m.cWord = STRTRAN(m.cWord, 'x', 'S', 1, 1)
            CASE LEFT(m.cWord, 2) = 'ps'
              m.cWord = STRTRAN(m.cWord, 'ps', 'S', 1, 1)
            CASE LEFT(m.cWord, 2) = 'pt'
              m.cWord = STRTRAN(m.cWord, 'pt', 'T', 1, 1)
          ENDCASE

          * Be careful about SUBSTR() accessing characters beyond end of string - normally it is
          * allowed, but when used in index expression the rules change for some reason.
          IF EMPTY(m.cTempBuffer)  && Only first word keeps leading vowel
            m.cWord = UPPER(CHRTRAN(LEFT(m.cWord, 1), 'aeiouyhw', 'AAAAAAAA')) + IIF(LEN(m.cWord) > 1, SUBSTR(m.cWord,2), '')
          ELSE
            * If not the first word, only leading g gets capped to prevent gh removal later.
            m.cWord = CHRTRAN(LEFT(m.cWord, 1), 'g', 'G') + IIF(LEN(m.cWord) > 1, SUBSTR(m.cWord,2), '')
          ENDIF

          * Special translations that apply only in the middle of a word.
          m.cWord = STRTRAN(m.cWord, 'gh', '')
          m.cWord = STRTRAN(m.cWord, 'x', 'KS')
        ENDIF
        m.cTempBuffer = m.cTempBuffer + m.cWord
      ENDIF
      m.nStart = 0
    ENDIF
  ENDFOR

  * Final processing of result string. Replace double letters with single & remove vowels.
  STORE '' TO m.ch, m.cLastCh, m.cResult
  FOR ix = 1 TO LEN(m.cTempBuffer)
    m.ch = SUBSTR(m.cTempBuffer, m.ix, 1)
    IF NOT UPPER(m.ch) == m.cLastCh AND NOT m.ch $ 'aeiouyhw'
      m.cResult = m.cResult + UPPER(m.ch)
    ENDIF
    m.cLastch = UPPER(m.ch)
  ENDFOR

  * Preserve original length for use in index expressions.
  RETURN PADR(m.cResult, LEN(m.cInString))

**__RI_HEADER!@ Do NOT REMOVE or MODIFY this line!!!! @!__RI_HEADER**
procedure RIDELETE
local llRetVal
llRetVal=.t.
 IF (ISRLOCKED() and !deleted()) OR !RLOCK()
    llRetVal=.F.
  ELSE
    IF !deleted()
      DELETE
      IF CURSORGETPROP('BUFFERING') > 1
      	=TABLEUPDATE()
      ENDIF
    ENDIF not already deleted
  ENDIF
  UNLOCK RECORD (RECNO())
  llRetVal=pnerror=0
RETURN llRetVal

procedure RIUPDATE
lparameters tcFieldName,tcNewValue,tcCascadeParent
local llRetVal
llRetVal=.t.
 IF ISRLOCKED() OR !RLOCK()
    llRetVal=.F.
  ELSE
    IF EVAL(tcFieldName)<>tcNewValue
      PRIVATE pcCascadeParent
      pcCascadeParent=upper(iif(type("tcCascadeParent")<>"C","",tcCascadeParent))
      REPLACE (tcFieldName) WITH tcNewValue
      IF CURSORGETPROP('BUFFERING') > 1
      	=TABLEUPDATE()
      ENDIF
    ENDIF values don't already match
  ENDIF it's locked already, or I was able to lock it
  UNLOCK RECORD (RECNO())
  llRetVal=pnerror=0
return llRetVal

procedure rierror
parameters tnErrNo,tcMessage,tcCode,tcProgram
local lnErrorRows,lnXX
lnErrorRows=alen(gaErrors,1)
if type('gaErrors[lnErrorRows,1]')<>"L"
  dimension gaErrors[lnErrorRows+1,alen(gaErrors,2)]
  lnErrorRows=lnErrorRows+1
endif
gaErrors[lnErrorRows,1]=tnErrNo
gaErrors[lnErrorRows,2]=tcMessage
gaErrors[lnErrorRows,3]=tcCode
gaErrors[lnErrorRows,4]=""
lnXX=1
do while !empty(program(lnXX))
  gaErrors[lnErrorRows,4]=gaErrors[lnErrorRows,4]+","+;
  program(lnXX)
  lnXX=lnXX+1
enddo
gaErrors[lnErrorRows,5]=pcParentDBF
gaErrors[lnErrorRows,6]=pnParentRec
gaErrors[lnErrorRows,7]=pcParentID
gaErrors[lnErrorRows,8]=pcParentExpr
gaErrors[lnErrorRows,9]=pcChildDBF
gaErrors[lnErrorRows,10]=pnChildRec
gaErrors[lnErrorRows,11]=pcChildID
gaErrors[lnErrorRows,12]=pcChildExpr
return tnErrNo


PROCEDURE riopen
PARAMETERS tcTable,tcOrder

LOCAL lcCurWkArea,lcNewWkArea,lnInUseSpot,lnOccurs,lnOccurance
lnInUseSpot=0
lnOccurs = OCCURS(UPPER(tcTable)+"*",UPPER(pcRIcursors))
FOR lnOccurance = 1 TO lnOccurs
	lnInUseSpot=ATC(tcTable+"*",pcRIcursors,lnOccurance)
	IF ISDIGIT(SUBSTR(pcRIcursors,lnInUseSpot-1,1)) OR;
		 EMPTY(SUBSTR(pcRIcursors,lnInUseSpot-1,1))
		EXIT
	ENDIF
	lnInUseSpot=0
ENDFOR

IF lnInUseSpot=0
  lcCurWkArea=select()
  SELECT 0
  lcNewWkArea=select()
  IF NOT EMPTY(tcOrder)
    USE (tcTable) AGAIN ORDER (tcOrder) ;
      ALIAS ("__ri"+LTRIM(STR(SELECT()))) share
  ELSE
    USE (tcTable) AGAIN ALIAS ("__ri"+LTRIM(STR(SELECT()))) share
  ENDIF
  if pnerror=0
    pcRIcursors=pcRIcursors+upper(tcTable)+"?"+STR(SELECT(),5)
  else
    lcNewWkArea=0
  endif something bad happened while attempting to open the file
ELSE
  lcNewWkArea=val(substr(pcRIcursors,lnInUseSpot+len(tcTable)+1,5))
  pcRIcursors = strtran(pcRIcursors,upper(tcTable)+"*"+str(lcNewWkArea,5),;
    upper(tcTable)+"?"+str(lcNewWkArea,5))
  IF NOT EMPTY(tcOrder)
    SET ORDER TO (tcOrder) IN (lcNewWkArea)
  ENDIF sent an order
  if pnerror<>0
    lcNewWkArea=0
  endif something bad happened while setting order
ENDIF
RETURN (lcNewWkArea)


PROCEDURE riend
PARAMETERS tlSuccess
local lnXX,lnSpot,lcWorkArea
IF tlSuccess
  END TRANSACTION
ELSE
  SET DELETED OFF
  ROLLBACK
  SET DELETED ON
ENDIF
IF EMPTY(pcRIolderror)
  ON ERROR
ELSE
  ON ERROR &pcRIolderror.
ENDIF
FOR lnXX=1 TO occurs("*",pcRIcursors)
  lnSpot=atc("*",pcRIcursors,lnXX)+1
  USE IN (VAL(substr(pcRIcursors,lnSpot,5)))
ENDFOR
IF pcOldCompat = "ON"
	SET COMPATIBLE ON
ENDIF
IF pcOldDele="OFF"
  SET DELETED OFF
ENDIF
IF pcOldExact="ON"
  SET EXACT ON
ENDIF
IF pcOldTalk="ON"
  SET TALK ON
ENDIF
do case
  case empty(pcOldDBC)
    set data to
  case pcOldDBC<>DBC()
    set data to (pcOldDBC)
endcase
RETURN .T.


PROCEDURE rireuse
* rireuse.prg
PARAMETERS tcTableName,tcWkArea
pcRIcursors = strtran(pcRIcursors,upper(tcTableName)+"?"+str(tcWkArea,5),;
  upper(tcTableName)+"*"+str(tcWkArea,5))
RETURN .t.

********************************************************************************
** "Referential integrity delete trigger for" afehdr
PROCEDURE __RI_DELETE_afehdr
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CIDAFEH TO lcParentID,pcParentID
pcParentExpr="CIDAFEH"
lcChildWkArea=riopen("afedet","cidafeh")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
SELECT (lcChildWkArea)
SEEK lcParentID
SCAN WHILE CIDAFEH=lcParentID AND llRetVal
  pnChildRec=recno()
  pcChildID=CIDAFEH
  pcChildExpr="CIDAFEH"
  llRetVal=ridelete()
ENDSCAN get all of the afedet records
=rireuse("afedet",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" afehdr
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_afehdr
** "Referential integrity update trigger for" afehdr
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CIDAFEH")
pcParentID=lcOldParentID
pcParentExpr="CIDAFEH"
lcParentID=CIDAFEH
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("afedet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CIDAFEH=lcOldParentID
    pnChildRec=recno()
    pcChildID=CIDAFEH
    pcChildExpr="CIDAFEH"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CIDAFEH",lcParentID,"AFEHDR")
  ENDSCAN get all of the afedet records
  =rireuse("afedet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" afehdr
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" appmthdr
PROCEDURE __RI_DELETE_appmthdr
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CBATCH TO lcParentID,pcParentID
pcParentExpr="CBATCH"
lcChildWkArea=riopen("appmtdet","cbatch")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
SELECT (lcChildWkArea)
SEEK lcParentID
SCAN WHILE CBATCH=lcParentID AND llRetVal
  pnChildRec=recno()
  pcChildID=CBATCH
  pcChildExpr="CBATCH"
  llRetVal=ridelete()
ENDSCAN get all of the appmtdet records
=rireuse("appmtdet",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" appmthdr
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_appmthdr
** "Referential integrity update trigger for" appmthdr
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CBATCH")
pcParentID=lcOldParentID
pcParentExpr="CBATCH"
lcParentID=CBATCH
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("appmtdet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CBATCH=lcOldParentID
    pnChildRec=recno()
    pcChildID=CBATCH
    pcChildExpr="CBATCH"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CBATCH",lcParentID,"APPMTHDR")
  ENDSCAN get all of the appmtdet records
  =rireuse("appmtdet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" appmthdr
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" appurchh
PROCEDURE __RI_DELETE_appurchh
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CBATCH TO lcParentID,pcParentID
pcParentExpr="CBATCH"
lcChildWkArea=riopen("appurchd","cbatch")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
SELECT (lcChildWkArea)
SEEK lcParentID
SCAN WHILE CBATCH=lcParentID AND llRetVal
  pnChildRec=recno()
  pcChildID=CBATCH
  pcChildExpr="CBATCH"
  llRetVal=ridelete()
ENDSCAN get all of the appurchd records
=rireuse("appurchd",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" appurchh
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_appurchh
** "Referential integrity update trigger for" appurchh
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CBATCH")
pcParentID=lcOldParentID
pcParentExpr="CBATCH"
lcParentID=CBATCH
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("appurchd")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CBATCH=lcOldParentID
    pnChildRec=recno()
    pcChildID=CBATCH
    pcChildExpr="CBATCH"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CBATCH",lcParentID,"APPURCHH")
  ENDSCAN get all of the appurchd records
  =rireuse("appurchd",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" appurchh
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" appurech
PROCEDURE __RI_DELETE_appurech
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CBATCH TO lcParentID,pcParentID
pcParentExpr="CBATCH"
lcChildWkArea=riopen("appurecd","cbatch")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
SELECT (lcChildWkArea)
SEEK lcParentID
SCAN WHILE CBATCH=lcParentID AND llRetVal
  pnChildRec=recno()
  pcChildID=CBATCH
  pcChildExpr="CBATCH"
  llRetVal=ridelete()
ENDSCAN get all of the appurecd records
=rireuse("appurecd",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" appurech
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_appurech
** "Referential integrity update trigger for" appurech
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CBATCH")
pcParentID=lcOldParentID
pcParentExpr="CBATCH"
lcParentID=CBATCH
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("appurecd")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CBATCH=lcOldParentID
    pnChildRec=recno()
    pcChildID=CBATCH
    pcChildExpr="CBATCH"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CBATCH",lcParentID,"APPURECH")
  ENDSCAN get all of the appurecd records
  =rireuse("appurecd",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" appurech
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" coa
PROCEDURE __RI_DELETE_coa
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CACCTNO TO lcParentID,pcParentID
pcParentExpr="CACCTNO"
lcChildWkArea=riopen("glmaster","acctno")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
llRetVal=!SEEK(lcParentID,lcChildWkArea)
SELECT (lcChildWkArea)
pnChildRec=recno()
pcChildID=CACCTNO
pcChildExpr="CACCTNO"
IF !llRetVal
  pnError = rierror(-1,"Delete restrict rule violated.","","")
ENDIF
=rireuse("glmaster",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CACCTNO TO lcParentID,pcParentID
pcParentExpr="CACCTNO"
lcChildWkArea=riopen("checks","cacctno")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
llRetVal=!SEEK(lcParentID,lcChildWkArea)
SELECT (lcChildWkArea)
pnChildRec=recno()
pcChildID=CACCTNO
pcChildExpr="CACCTNO"
IF !llRetVal
  pnError = rierror(-1,"Delete restrict rule violated.","","")
ENDIF
=rireuse("checks",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" coa
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_coa
** "Referential integrity update trigger for" coa
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CACCTNO")
pcParentID=lcOldParentID
pcParentExpr="CACCTNO"
lcParentID=CACCTNO
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("glmaster")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CACCTNO=lcOldParentID
    pnChildRec=recno()
    pcChildID=CACCTNO
    pcChildExpr="CACCTNO"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CACCTNO",lcParentID,"COA")
  ENDSCAN get all of the glmaster records
  =rireuse("glmaster",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CACCTNO")
pcParentID=lcOldParentID
pcParentExpr="CACCTNO"
lcParentID=CACCTNO
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("appurecd")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CACCTNO=lcOldParentID
    pnChildRec=recno()
    pcChildID=CACCTNO
    pcChildExpr="CACCTNO"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CACCTNO",lcParentID,"COA")
  ENDSCAN get all of the appurecd records
  =rireuse("appurecd",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CACCTNO")
pcParentID=lcOldParentID
pcParentExpr="CACCTNO"
lcParentID=CACCTNO
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("checks")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CACCTNO=lcOldParentID
    pnChildRec=recno()
    pcChildID=CACCTNO
    pcChildExpr="CACCTNO"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CACCTNO",lcParentID,"COA")
  ENDSCAN get all of the checks records
  =rireuse("checks",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CACCTNO")
pcParentID=lcOldParentID
pcParentExpr="CACCTNO"
lcParentID=CACCTNO
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("appurchd")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CACCTNO=lcOldParentID
    pnChildRec=recno()
    pcChildID=CACCTNO
    pcChildExpr="CACCTNO"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CACCTNO",lcParentID,"COA")
  ENDSCAN get all of the appurchd records
  =rireuse("appurchd",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CACCTNO")
pcParentID=lcOldParentID
pcParentExpr="CACCTNO"
lcParentID=CACCTNO
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("invdet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CACCTNO=lcOldParentID
    pnChildRec=recno()
    pcChildID=CACCTNO
    pcChildExpr="CACCTNO"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CACCTNO",lcParentID,"COA")
  ENDSCAN get all of the invdet records
  =rireuse("invdet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CACCTNO")
pcParentID=lcOldParentID
pcParentExpr="CACCTNO"
lcParentID=CACCTNO
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("expcat")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CCRACCTO=lcOldParentID
    pnChildRec=recno()
    pcChildID=CCRACCTO
    pcChildExpr="CCRACCTO"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CCRACCTO",lcParentID,"COA")
  ENDSCAN get all of the expcat records
  =rireuse("expcat",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CACCTNO")
pcParentID=lcOldParentID
pcParentExpr="CACCTNO"
lcParentID=CACCTNO
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("expcat")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CCRACCTV=lcOldParentID
    pnChildRec=recno()
    pcChildID=CCRACCTV
    pcChildExpr="CCRACCTV"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CCRACCTV",lcParentID,"COA")
  ENDSCAN get all of the expcat records
  =rireuse("expcat",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CACCTNO")
pcParentID=lcOldParentID
pcParentExpr="CACCTNO"
lcParentID=CACCTNO
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("expcat")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CDRACCTO=lcOldParentID
    pnChildRec=recno()
    pcChildID=CDRACCTO
    pcChildExpr="CDRACCTO"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CDRACCTO",lcParentID,"COA")
  ENDSCAN get all of the expcat records
  =rireuse("expcat",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CACCTNO")
pcParentID=lcOldParentID
pcParentExpr="CACCTNO"
lcParentID=CACCTNO
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("expcat")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CDRACCTV=lcOldParentID
    pnChildRec=recno()
    pcChildID=CDRACCTV
    pcChildExpr="CDRACCTV"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CDRACCTV",lcParentID,"COA")
  ENDSCAN get all of the expcat records
  =rireuse("expcat",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" coa
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" csdishdr
PROCEDURE __RI_DELETE_csdishdr
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CBATCH TO lcParentID,pcParentID
pcParentExpr="CBATCH"
lcChildWkArea=riopen("csdisdet","cbatch")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
SELECT (lcChildWkArea)
SEEK lcParentID
SCAN WHILE CBATCH=lcParentID AND llRetVal
  pnChildRec=recno()
  pcChildID=CBATCH
  pcChildExpr="CBATCH"
  llRetVal=ridelete()
ENDSCAN get all of the csdisdet records
=rireuse("csdisdet",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" csdishdr
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_csdishdr
** "Referential integrity update trigger for" csdishdr
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CBATCH")
pcParentID=lcOldParentID
pcParentExpr="CBATCH"
lcParentID=CBATCH
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("csdisdet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CBATCH=lcOldParentID
    pnChildRec=recno()
    pcChildID=CBATCH
    pcChildExpr="CBATCH"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CBATCH",lcParentID,"CSDISHDR")
  ENDSCAN get all of the csdisdet records
  =rireuse("csdisdet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" csdishdr
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" csrcthdr
PROCEDURE __RI_DELETE_csrcthdr
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CBATCH TO lcParentID,pcParentID
pcParentExpr="CBATCH"
lcChildWkArea=riopen("csrctdet","cbatch")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
SELECT (lcChildWkArea)
SEEK lcParentID
SCAN WHILE CBATCH=lcParentID AND llRetVal
  pnChildRec=recno()
  pcChildID=CBATCH
  pcChildExpr="CBATCH"
  llRetVal=ridelete()
ENDSCAN get all of the csrctdet records
=rireuse("csrctdet",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" csrcthdr
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_csrcthdr
** "Referential integrity update trigger for" csrcthdr
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CBATCH")
pcParentID=lcOldParentID
pcParentExpr="CBATCH"
lcParentID=CBATCH
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("csrctdet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CBATCH=lcOldParentID
    pnChildRec=recno()
    pcChildID=CBATCH
    pcChildExpr="CBATCH"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CBATCH",lcParentID,"CSRCTHDR")
  ENDSCAN get all of the csrctdet records
  =rireuse("csrctdet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" csrcthdr
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_custs
** "Referential integrity update trigger for" custs
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("UPPER(CCUSTID)")
pcParentID=lcOldParentID
pcParentExpr="UPPER(CCUSTID)"
lcParentID=UPPER(CCUSTID)
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("invhdr")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CCUSTID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CCUSTID
    pcChildExpr="CCUSTID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CCUSTID",lcParentID,"CUSTS")
  ENDSCAN get all of the invhdr records
  =rireuse("invhdr",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("UPPER(CCUSTID)")
pcParentID=lcOldParentID
pcParentExpr="UPPER(CCUSTID)"
lcParentID=UPPER(CCUSTID)
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("glmaster")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CID
    pcChildExpr="CID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CID",lcParentID,"CUSTS")
  ENDSCAN get all of the glmaster records
  =rireuse("glmaster",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("UPPER(CCUSTID)")
pcParentID=lcOldParentID
pcParentExpr="UPPER(CCUSTID)"
lcParentID=UPPER(CCUSTID)
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("arpmthdr")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CCUSTID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CCUSTID
    pcChildExpr="CCUSTID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CCUSTID",lcParentID,"CUSTS")
  ENDSCAN get all of the arpmthdr records
  =rireuse("arpmthdr",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("UPPER(CCUSTID)")
pcParentID=lcOldParentID
pcParentExpr="UPPER(CCUSTID)"
lcParentID=UPPER(CCUSTID)
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("checks")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CID
    pcChildExpr="CID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CID",lcParentID,"CUSTS")
  ENDSCAN get all of the checks records
  =rireuse("checks",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" custs
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" deposits
PROCEDURE __RI_DELETE_deposits
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CBATCH TO lcParentID,pcParentID
pcParentExpr="CBATCH"
lcChildWkArea=riopen("depositd","cbatch")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
SELECT (lcChildWkArea)
SEEK lcParentID
SCAN WHILE CBATCH=lcParentID AND llRetVal
  pnChildRec=recno()
  pcChildID=CBATCH
  pcChildExpr="CBATCH"
  llRetVal=ridelete()
ENDSCAN get all of the depositd records
=rireuse("depositd",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" deposits
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_deposits
** "Referential integrity update trigger for" deposits
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CBATCH")
pcParentID=lcOldParentID
pcParentExpr="CBATCH"
lcParentID=CBATCH
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("depositd")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CBATCH=lcOldParentID
    pnChildRec=recno()
    pcChildID=CBATCH
    pcChildExpr="CBATCH"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CBATCH",lcParentID,"DEPOSITS")
  ENDSCAN get all of the depositd records
  =rireuse("depositd",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" deposits
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_disposal
** "Referential integrity update trigger for" disposal
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CDISPERM")
pcParentID=lcOldParentID
pcParentExpr="CDISPERM"
lcParentID=CDISPERM
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("brinelog")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CDISPERM=lcOldParentID
    pnChildRec=recno()
    pcChildID=CDISPERM
    pcChildExpr="CDISPERM"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CDISPERM",lcParentID,"DISPOSAL")
  ENDSCAN get all of the brinelog records
  =rireuse("brinelog",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CDISPERM")
pcParentID=lcOldParentID
pcParentExpr="CDISPERM"
lcParentID=CDISPERM
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("items")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CDISPERM=lcOldParentID
    pnChildRec=recno()
    pcChildID=CDISPERM
    pcChildExpr="CDISPERM"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CDISPERM",lcParentID,"DISPOSAL")
  ENDSCAN get all of the items records
  =rireuse("items",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" disposal
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" emps
PROCEDURE __RI_DELETE_emps
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CEMPID TO lcParentID,pcParentID
pcParentExpr="CEMPID"
lcChildWkArea=riopen("prdata","cempid")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
llRetVal=!SEEK(lcParentID,lcChildWkArea)
SELECT (lcChildWkArea)
pnChildRec=recno()
pcChildID=CEMPID
pcChildExpr="CEMPID"
IF !llRetVal
  pnError = rierror(-1,"Delete restrict rule violated.","","")
ENDIF
=rireuse("prdata",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" emps
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_emps
** "Referential integrity update trigger for" emps
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CEMPID")
pcParentID=lcOldParentID
pcParentExpr="CEMPID"
lcParentID=CEMPID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("glmaster")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CID
    pcChildExpr="CID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CID",lcParentID,"EMPS")
  ENDSCAN get all of the glmaster records
  =rireuse("glmaster",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CEMPID")
pcParentID=lcOldParentID
pcParentExpr="CEMPID"
lcParentID=CEMPID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("prdata")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CEMPID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CEMPID
    pcChildExpr="CEMPID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CEMPID",lcParentID,"EMPS")
  ENDSCAN get all of the prdata records
  =rireuse("prdata",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CEMPID")
pcParentID=lcOldParentID
pcParentExpr="CEMPID"
lcParentID=CEMPID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("premptax")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CEMPID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CEMPID
    pcChildExpr="CEMPID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CEMPID",lcParentID,"EMPS")
  ENDSCAN get all of the premptax records
  =rireuse("premptax",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CEMPID")
pcParentID=lcOldParentID
pcParentExpr="CEMPID"
lcParentID=CEMPID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("prcodes")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CEMPID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CEMPID
    pcChildExpr="CEMPID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CEMPID",lcParentID,"EMPS")
  ENDSCAN get all of the prcodes records
  =rireuse("prcodes",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CEMPID")
pcParentID=lcOldParentID
pcParentExpr="CEMPID"
lcParentID=CEMPID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("checks")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CID
    pcChildExpr="CID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CID",lcParentID,"EMPS")
  ENDSCAN get all of the checks records
  =rireuse("checks",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" emps
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_expcat
** "Referential integrity update trigger for" expcat
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CCATCODE")
pcParentID=lcOldParentID
pcParentExpr="CCATCODE"
lcParentID=CCATCODE
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("expense")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CCATCODE=lcOldParentID
    pnChildRec=recno()
    pcChildID=CCATCODE
    pcChildExpr="CCATCODE"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CCATCODE",lcParentID,"EXPCAT")
  ENDSCAN get all of the expense records
  =rireuse("expense",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CCATCODE")
pcParentID=lcOldParentID
pcParentExpr="CCATCODE"
lcParentID=CCATCODE
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("expsusp")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CCATCODE=lcOldParentID
    pnChildRec=recno()
    pcChildID=CCATCODE
    pcChildExpr="CCATCODE"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CCATCODE",lcParentID,"EXPCAT")
  ENDSCAN get all of the expsusp records
  =rireuse("expsusp",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CCATCODE")
pcParentID=lcOldParentID
pcParentExpr="CCATCODE"
lcParentID=CCATCODE
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("glmaster")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CCATCODE=lcOldParentID
    pnChildRec=recno()
    pcChildID=CCATCODE
    pcChildExpr="CCATCODE"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CCATCODE",lcParentID,"EXPCAT")
  ENDSCAN get all of the glmaster records
  =rireuse("glmaster",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CCATCODE")
pcParentID=lcOldParentID
pcParentExpr="CCATCODE"
lcParentID=CCATCODE
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("appurecd")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CCATCODE=lcOldParentID
    pnChildRec=recno()
    pcChildID=CCATCODE
    pcChildExpr="CCATCODE"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CCATCODE",lcParentID,"EXPCAT")
  ENDSCAN get all of the appurecd records
  =rireuse("appurecd",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CCATCODE")
pcParentID=lcOldParentID
pcParentExpr="CCATCODE"
lcParentID=CCATCODE
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("appurchd")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CCATCODE=lcOldParentID
    pnChildRec=recno()
    pcChildID=CCATCODE
    pcChildExpr="CCATCODE"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CCATCODE",lcParentID,"EXPCAT")
  ENDSCAN get all of the appurchd records
  =rireuse("appurchd",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CCATCODE")
pcParentID=lcOldParentID
pcParentExpr="CCATCODE"
lcParentID=CCATCODE
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("csrctdet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CTYPE=lcOldParentID
    pnChildRec=recno()
    pcChildID=CTYPE
    pcChildExpr="CTYPE"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CTYPE",lcParentID,"EXPCAT")
  ENDSCAN get all of the csrctdet records
  =rireuse("csrctdet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CCATCODE")
pcParentID=lcOldParentID
pcParentExpr="CCATCODE"
lcParentID=CCATCODE
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("afeowner")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CCATCODE=lcOldParentID
    pnChildRec=recno()
    pcChildID=CCATCODE
    pcChildExpr="CCATCODE"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CCATCODE",lcParentID,"EXPCAT")
  ENDSCAN get all of the afeowner records
  =rireuse("afeowner",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CCATCODE")
pcParentID=lcOldParentID
pcParentExpr="CCATCODE"
lcParentID=CCATCODE
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("afedet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CCATCODE=lcOldParentID
    pnChildRec=recno()
    pcChildID=CCATCODE
    pcChildExpr="CCATCODE"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CCATCODE",lcParentID,"EXPCAT")
  ENDSCAN get all of the afedet records
  =rireuse("afedet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" expcat
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_gasown
** "Referential integrity update trigger for" gasown
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CMETERNO")
pcParentID=lcOldParentID
pcParentExpr="CMETERNO"
lcParentID=CMETERNO
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("gasinv")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CMETERNO=lcOldParentID
    pnChildRec=recno()
    pcChildID=CMETERNO
    pcChildExpr="CMETERNO"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CMETERNO",lcParentID,"GASOWN")
  ENDSCAN get all of the gasinv records
  =rireuse("gasinv",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CMETERNO")
pcParentID=lcOldParentID
pcParentExpr="CMETERNO"
lcParentID=CMETERNO
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("gasuse")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CMETERNO=lcOldParentID
    pnChildRec=recno()
    pcChildID=CMETERNO
    pcChildExpr="CMETERNO"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CMETERNO",lcParentID,"GASOWN")
  ENDSCAN get all of the gasuse records
  =rireuse("gasuse",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CMETERNO")
pcParentID=lcOldParentID
pcParentExpr="CMETERNO"
lcParentID=CMETERNO
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("gasuse")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CMETERNO+COWNERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CMETERNO+COWNERID
    pcChildExpr="CMETERNO+COWNERID"
    llRetVal=riupdate("CMETERNO",substr(lcParentID,1,15),"gasown")
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
  ENDSCAN get all of the gasuse records
  =rireuse("gasuse",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" gasown
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" glrecur
PROCEDURE __RI_DELETE_glrecur
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CBATCH TO lcParentID,pcParentID
pcParentExpr="CBATCH"
lcChildWkArea=riopen("glredet","batch")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
SELECT (lcChildWkArea)
SEEK lcParentID
SCAN WHILE CBATCH=lcParentID AND llRetVal
  pnChildRec=recno()
  pcChildID=CBATCH
  pcChildExpr="CBATCH"
  llRetVal=ridelete()
ENDSCAN get all of the glredet records
=rireuse("glredet",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" glrecur
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_glrecur
** "Referential integrity update trigger for" glrecur
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CBATCH")
pcParentID=lcOldParentID
pcParentExpr="CBATCH"
lcParentID=CBATCH
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("glredet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CBATCH=lcOldParentID
    pnChildRec=recno()
    pcChildID=CBATCH
    pcChildExpr="CBATCH"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CBATCH",lcParentID,"GLRECUR")
  ENDSCAN get all of the glredet records
  =rireuse("glredet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" glrecur
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_groups
** "Referential integrity update trigger for" groups
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CGROUP")
pcParentID=lcOldParentID
pcParentExpr="CGROUP"
lcParentID=CGROUP
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("suspense")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CGROUP=lcOldParentID
    pnChildRec=recno()
    pcChildID=CGROUP
    pcChildExpr="CGROUP"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CGROUP",lcParentID,"GROUPS")
  ENDSCAN get all of the suspense records
  =rireuse("suspense",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CGROUP")
pcParentID=lcOldParentID
pcParentExpr="CGROUP"
lcParentID=CGROUP
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("wells")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR UPPER(CGROUP)=lcOldParentID
    pnChildRec=recno()
    pcChildID=UPPER(CGROUP)
    pcChildExpr="UPPER(CGROUP)"
    llRetVal=riupdate("CGROUP",substr(lcParentID,1,2),"groups")
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
  ENDSCAN get all of the wells records
  =rireuse("wells",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" groups
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_investor
** "Referential integrity update trigger for" investor
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("susaudit")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR COWNERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=COWNERID
    pcChildExpr="COWNERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("COWNERID",lcParentID,"INVESTOR")
  ENDSCAN get all of the susaudit records
  =rireuse("susaudit",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("invhdr")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CCUSTID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CCUSTID
    pcChildExpr="CCUSTID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CCUSTID",lcParentID,"INVESTOR")
  ENDSCAN get all of the invhdr records
  =rireuse("invhdr",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("checks")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CID
    pcChildExpr="CID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CID",lcParentID,"INVESTOR")
  ENDSCAN get all of the checks records
  =rireuse("checks",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("disbhist")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR COWNERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=COWNERID
    pcChildExpr="COWNERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("COWNERID",lcParentID,"INVESTOR")
  ENDSCAN get all of the disbhist records
  =rireuse("disbhist",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("csdisdet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR COWNERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=COWNERID
    pcChildExpr="COWNERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("COWNERID",lcParentID,"INVESTOR")
  ENDSCAN get all of the csdisdet records
  =rireuse("csdisdet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("appurchd")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR COWNERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=COWNERID
    pcChildExpr="COWNERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("COWNERID",lcParentID,"INVESTOR")
  ENDSCAN get all of the appurchd records
  =rireuse("appurchd",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("expense")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR COWNERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=COWNERID
    pcChildExpr="COWNERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("COWNERID",lcParentID,"INVESTOR")
  ENDSCAN get all of the expense records
  =rireuse("expense",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("incsusp")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR COWNERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=COWNERID
    pcChildExpr="COWNERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("COWNERID",lcParentID,"INVESTOR")
  ENDSCAN get all of the incsusp records
  =rireuse("incsusp",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("expsusp")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR COWNERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=COWNERID
    pcChildExpr="COWNERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("COWNERID",lcParentID,"INVESTOR")
  ENDSCAN get all of the expsusp records
  =rireuse("expsusp",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("csrctdet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR COWNERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=COWNERID
    pcChildExpr="COWNERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("COWNERID",lcParentID,"INVESTOR")
  ENDSCAN get all of the csrctdet records
  =rireuse("csrctdet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("landhist")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR COWNERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=COWNERID
    pcChildExpr="COWNERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("COWNERID",lcParentID,"INVESTOR")
  ENDSCAN get all of the landhist records
  =rireuse("landhist",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("landowner")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR COWNERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=COWNERID
    pcChildExpr="COWNERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("COWNERID",lcParentID,"INVESTOR")
  ENDSCAN get all of the landowner records
  =rireuse("landowner",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("suspense")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR COWNERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=COWNERID
    pcChildExpr="COWNERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("COWNERID",lcParentID,"INVESTOR")
  ENDSCAN get all of the suspense records
  =rireuse("suspense",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("glmaster")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CID
    pcChildExpr="CID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CID",lcParentID,"INVESTOR")
  ENDSCAN get all of the glmaster records
  =rireuse("glmaster",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("tax1099")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CID
    pcChildExpr="CID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CID",lcParentID,"INVESTOR")
  ENDSCAN get all of the tax1099 records
  =rireuse("tax1099",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("prepayh")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR COWNERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=COWNERID
    pcChildExpr="COWNERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("COWNERID",lcParentID,"INVESTOR")
  ENDSCAN get all of the prepayh records
  =rireuse("prepayh",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("prepayd")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR COWNERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=COWNERID
    pcChildExpr="COWNERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("COWNERID",lcParentID,"INVESTOR")
  ENDSCAN get all of the prepayd records
  =rireuse("prepayd",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("arpmthdr")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CCUSTID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CCUSTID
    pcChildExpr="CCUSTID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CCUSTID",lcParentID,"INVESTOR")
  ENDSCAN get all of the arpmthdr records
  =rireuse("arpmthdr",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("gasuse")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR COWNERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=COWNERID
    pcChildExpr="COWNERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("COWNERID",lcParentID,"INVESTOR")
  ENDSCAN get all of the gasuse records
  =rireuse("gasuse",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("gasown")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR COWNERID+CMETERNO=lcOldParentID
    pnChildRec=recno()
    pcChildID=COWNERID+CMETERNO
    pcChildExpr="COWNERID+CMETERNO"
    llRetVal=riupdate("COWNERID",substr(lcParentID,1,10),"investor")
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
  ENDSCAN get all of the gasown records
  =rireuse("gasown",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("arpmtdet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CCUSTID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CCUSTID
    pcChildExpr="CCUSTID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CCUSTID",lcParentID,"INVESTOR")
  ENDSCAN get all of the arpmtdet records
  =rireuse("arpmtdet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("COWNERID")
pcParentID=lcOldParentID
pcParentExpr="COWNERID"
lcParentID=COWNERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("wellinv")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR COWNERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=COWNERID
    pcChildExpr="COWNERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("COWNERID",lcParentID,"INVESTOR")
  ENDSCAN get all of the wellinv records
  =rireuse("wellinv",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" investor
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" invhdr
PROCEDURE __RI_DELETE_invhdr
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CBATCH TO lcParentID,pcParentID
pcParentExpr="CBATCH"
lcChildWkArea=riopen("invdet","cbatch")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
SELECT (lcChildWkArea)
SEEK lcParentID
SCAN WHILE CBATCH=lcParentID AND llRetVal
  pnChildRec=recno()
  pcChildID=CBATCH
  pcChildExpr="CBATCH"
  llRetVal=ridelete()
ENDSCAN get all of the invdet records
=rireuse("invdet",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" invhdr
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_invhdr
** "Referential integrity update trigger for" invhdr
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CBATCH")
pcParentID=lcOldParentID
pcParentExpr="CBATCH"
lcParentID=CBATCH
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("invdet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CBATCH=lcOldParentID
    pnChildRec=recno()
    pcChildID=CBATCH
    pcChildExpr="CBATCH"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CBATCH",lcParentID,"INVHDR")
  ENDSCAN get all of the invdet records
  =rireuse("invdet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" invhdr
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" invrech
PROCEDURE __RI_DELETE_invrech
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CBATCH TO lcParentID,pcParentID
pcParentExpr="CBATCH"
lcChildWkArea=riopen("invrecd","cbatch")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
SELECT (lcChildWkArea)
SEEK lcParentID
SCAN WHILE CBATCH=lcParentID AND llRetVal
  pnChildRec=recno()
  pcChildID=CBATCH
  pcChildExpr="CBATCH"
  llRetVal=ridelete()
ENDSCAN get all of the invrecd records
=rireuse("invrecd",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" invrech
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_invrech
** "Referential integrity update trigger for" invrech
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CBATCH")
pcParentID=lcOldParentID
pcParentExpr="CBATCH"
lcParentID=CBATCH
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("invrecd")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CBATCH=lcOldParentID
    pnChildRec=recno()
    pcChildID=CBATCH
    pcChildExpr="CBATCH"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CBATCH",lcParentID,"INVRECH")
  ENDSCAN get all of the invrecd records
  =rireuse("invrecd",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" invrech
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" items
PROCEDURE __RI_DELETE_items
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CITEMID TO lcParentID,pcParentID
pcParentExpr="CITEMID"
lcChildWkArea=riopen("invdet","citemid")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
llRetVal=!SEEK(lcParentID,lcChildWkArea)
SELECT (lcChildWkArea)
pnChildRec=recno()
pcChildID=CITEMID
pcChildExpr="CITEMID"
IF !llRetVal
  pnError = rierror(-1,"Delete restrict rule violated.","","")
ENDIF
=rireuse("invdet",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" items
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_items
** "Referential integrity update trigger for" items
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CITEMID")
pcParentID=lcOldParentID
pcParentExpr="CITEMID"
lcParentID=CITEMID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("invdet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CITEMID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CITEMID
    pcChildExpr="CITEMID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CITEMID",lcParentID,"ITEMS")
  ENDSCAN get all of the invdet records
  =rireuse("invdet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CITEMID")
pcParentID=lcOldParentID
pcParentExpr="CITEMID"
lcParentID=CITEMID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("invtrans")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CITEMID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CITEMID
    pcChildExpr="CITEMID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CITEMID",lcParentID,"ITEMS")
  ENDSCAN get all of the invtrans records
  =rireuse("invtrans",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CITEMID")
pcParentID=lcOldParentID
pcParentExpr="CITEMID"
lcParentID=CITEMID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("appurecd")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CITEMID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CITEMID
    pcChildExpr="CITEMID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CITEMID",lcParentID,"ITEMS")
  ENDSCAN get all of the appurecd records
  =rireuse("appurecd",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" items
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" land
PROCEDURE __RI_DELETE_land
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CLEASEID TO lcParentID,pcParentID
pcParentExpr="CLEASEID"
lcChildWkArea=riopen("landowner","cleaseid")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
SELECT (lcChildWkArea)
SEEK lcParentID
SCAN WHILE CLEASEID=lcParentID AND llRetVal
  pnChildRec=recno()
  pcChildID=CLEASEID
  pcChildExpr="CLEASEID"
  llRetVal=ridelete()
ENDSCAN get all of the landowner records
=rireuse("landowner",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CLEASEID TO lcParentID,pcParentID
pcParentExpr="CLEASEID"
lcChildWkArea=riopen("leasewell","cleaseid")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
SELECT (lcChildWkArea)
SEEK lcParentID
SCAN WHILE CLEASEID=lcParentID AND llRetVal
  pnChildRec=recno()
  pcChildID=CLEASEID
  pcChildExpr="CLEASEID"
  llRetVal=ridelete()
ENDSCAN get all of the leasewell records
=rireuse("leasewell",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" land
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_land
** "Referential integrity update trigger for" land
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CLEASEID")
pcParentID=lcOldParentID
pcParentExpr="CLEASEID"
lcParentID=CLEASEID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("landhist")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CLEASEID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CLEASEID
    pcChildExpr="CLEASEID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CLEASEID",lcParentID,"LAND")
  ENDSCAN get all of the landhist records
  =rireuse("landhist",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CLEASEID")
pcParentID=lcOldParentID
pcParentExpr="CLEASEID"
lcParentID=CLEASEID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("landowner")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CLEASEID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CLEASEID
    pcChildExpr="CLEASEID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CLEASEID",lcParentID,"LAND")
  ENDSCAN get all of the landowner records
  =rireuse("landowner",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CLEASEID")
pcParentID=lcOldParentID
pcParentExpr="CLEASEID"
lcParentID=CLEASEID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("leasewell")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CLEASEID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CLEASEID
    pcChildExpr="CLEASEID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CLEASEID",lcParentID,"LAND")
  ENDSCAN get all of the leasewell records
  =rireuse("leasewell",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CLEASEID")
pcParentID=lcOldParentID
pcParentExpr="CLEASEID"
lcParentID=CLEASEID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("wells")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR UPPER(CLEASEID)=lcOldParentID
    pnChildRec=recno()
    pcChildID=UPPER(CLEASEID)
    pcChildExpr="UPPER(CLEASEID)"
    llRetVal=riupdate("CLEASEID",substr(lcParentID,1,10),"land")
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
  ENDSCAN get all of the wells records
  =rireuse("wells",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" land
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" meterall
PROCEDURE __RI_DELETE_meterall
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CBATCH TO lcParentID,pcParentID
pcParentExpr="CBATCH"
lcChildWkArea=riopen("metersub","cbatch")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
SELECT (lcChildWkArea)
SEEK lcParentID
SCAN WHILE CBATCH=lcParentID AND llRetVal
  pnChildRec=recno()
  pcChildID=CBATCH
  pcChildExpr="CBATCH"
  llRetVal=ridelete()
ENDSCAN get all of the metersub records
=rireuse("metersub",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" meterall
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_meterall
** "Referential integrity update trigger for" meterall
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CBATCH")
pcParentID=lcOldParentID
pcParentExpr="CBATCH"
lcParentID=CBATCH
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("metersub")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CBATCH=lcOldParentID
    pnChildRec=recno()
    pcChildID=CBATCH
    pcChildExpr="CBATCH"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CBATCH",lcParentID,"METERALL")
  ENDSCAN get all of the metersub records
  =rireuse("metersub",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" meterall
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_meters
** "Referential integrity update trigger for" meters
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CMETERID")
pcParentID=lcOldParentID
pcParentExpr="CMETERID"
lcParentID=CMETERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("metersub")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CMETERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CMETERID
    pcChildExpr="CMETERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CMETERID",lcParentID,"METERS")
  ENDSCAN get all of the metersub records
  =rireuse("metersub",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CMETERID")
pcParentID=lcOldParentID
pcParentExpr="CMETERID"
lcParentID=CMETERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("meterall")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CMETERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CMETERID
    pcChildExpr="CMETERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CMETERID",lcParentID,"METERS")
  ENDSCAN get all of the meterall records
  =rireuse("meterall",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CMETERID")
pcParentID=lcOldParentID
pcParentExpr="CMETERID"
lcParentID=CMETERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("meterdata")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CMETERID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CMETERID
    pcChildExpr="CMETERID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CMETERID",lcParentID,"METERS")
  ENDSCAN get all of the meterdata records
  =rireuse("meterdata",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CMETERID")
pcParentID=lcOldParentID
pcParentExpr="CMETERID"
lcParentID=CMETERID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("wells")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR UPPER(CMETERID)=lcOldParentID
    pnChildRec=recno()
    pcChildID=UPPER(CMETERID)
    pcChildExpr="UPPER(CMETERID)"
    llRetVal=riupdate("CMETERID",substr(lcParentID,1,15),"meters")
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
  ENDSCAN get all of the wells records
  =rireuse("wells",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" meters
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" proghsth
PROCEDURE __RI_DELETE_proghsth
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CBATCH TO lcParentID,pcParentID
pcParentExpr="CBATCH"
lcChildWkArea=riopen("proghstd","cbatch")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
SELECT (lcChildWkArea)
SEEK lcParentID
SCAN WHILE CBATCH=lcParentID AND llRetVal
  pnChildRec=recno()
  pcChildID=CBATCH
  pcChildExpr="CBATCH"
  llRetVal=ridelete()
ENDSCAN get all of the proghstd records
=rireuse("proghstd",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" proghsth
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_proghsth
** "Referential integrity update trigger for" proghsth
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CBATCH")
pcParentID=lcOldParentID
pcParentExpr="CBATCH"
lcParentID=CBATCH
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("proghstd")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CBATCH=lcOldParentID
    pnChildRec=recno()
    pcChildID=CBATCH
    pcChildExpr="CBATCH"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CBATCH",lcParentID,"PROGHSTH")
  ENDSCAN get all of the proghstd records
  =rireuse("proghstd",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" proghsth
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" programs
PROCEDURE __RI_DELETE_programs
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CPROGCODE TO lcParentID,pcParentID
pcParentExpr="CPROGCODE"
lcChildWkArea=riopen("progrel","cprogcode")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
SELECT (lcChildWkArea)
SEEK lcParentID
SCAN WHILE CPROGCODE=lcParentID AND llRetVal
  pnChildRec=recno()
  pcChildID=CPROGCODE
  pcChildExpr="CPROGCODE"
  llRetVal=ridelete()
ENDSCAN get all of the progrel records
=rireuse("progrel",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CPROGCODE TO lcParentID,pcParentID
pcParentExpr="CPROGCODE"
lcChildWkArea=riopen("proghsth","cprogcode")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
llRetVal=!SEEK(lcParentID,lcChildWkArea)
SELECT (lcChildWkArea)
pnChildRec=recno()
pcChildID=CPROGCODE
pcChildExpr="CPROGCODE"
IF !llRetVal
  pnError = rierror(-1,"Delete restrict rule violated.","","")
ENDIF
=rireuse("proghsth",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" programs
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_programs
** "Referential integrity update trigger for" programs
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CPROGCODE")
pcParentID=lcOldParentID
pcParentExpr="CPROGCODE"
lcParentID=CPROGCODE
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("progrel")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CPROGCODE=lcOldParentID
    pnChildRec=recno()
    pcChildID=CPROGCODE
    pcChildExpr="CPROGCODE"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CPROGCODE",lcParentID,"PROGRAMS")
  ENDSCAN get all of the progrel records
  =rireuse("progrel",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CPROGCODE")
pcParentID=lcOldParentID
pcParentExpr="CPROGCODE"
lcParentID=CPROGCODE
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("proghsth")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CPROGCODE=lcOldParentID
    pnChildRec=recno()
    pcChildID=CPROGCODE
    pcChildExpr="CPROGCODE"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CPROGCODE",lcParentID,"PROGRAMS")
  ENDSCAN get all of the proghsth records
  =rireuse("proghsth",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CPROGCODE")
pcParentID=lcOldParentID
pcParentExpr="CPROGCODE"
lcParentID=CPROGCODE
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("form1065")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CPROGCODE=lcOldParentID
    pnChildRec=recno()
    pcChildID=CPROGCODE
    pcChildExpr="CPROGCODE"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CPROGCODE",lcParentID,"PROGRAMS")
  ENDSCAN get all of the form1065 records
  =rireuse("form1065",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CPROGCODE")
pcParentID=lcOldParentID
pcParentExpr="CPROGCODE"
lcParentID=CPROGCODE
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("k1file")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CPROGCODE=lcOldParentID
    pnChildRec=recno()
    pcChildID=CPROGCODE
    pcChildExpr="CPROGCODE"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CPROGCODE",lcParentID,"PROGRAMS")
  ENDSCAN get all of the k1file records
  =rireuse("k1file",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CPROGCODE")
pcParentID=lcOldParentID
pcParentExpr="CPROGCODE"
lcParentID=CPROGCODE
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("wellinv")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CPROGCODE=lcOldParentID
    pnChildRec=recno()
    pcChildID=CPROGCODE
    pcChildExpr="CPROGCODE"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CPROGCODE",lcParentID,"PROGRAMS")
  ENDSCAN get all of the wellinv records
  =rireuse("wellinv",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" programs
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_pumpers
** "Referential integrity update trigger for" pumpers
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CIDPUMPER")
pcParentID=lcOldParentID
pcParentExpr="CIDPUMPER"
lcParentID=CIDPUMPER
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("wells")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CIDPUMPER=lcOldParentID
    pnChildRec=recno()
    pcChildID=CIDPUMPER
    pcChildExpr="CIDPUMPER"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CIDPUMPER",lcParentID,"PUMPERS")
  ENDSCAN get all of the wells records
  =rireuse("wells",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" pumpers
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_revsrc
** "Referential integrity update trigger for" revsrc
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CREVKEY")
pcParentID=lcOldParentID
pcParentExpr="CREVKEY"
lcParentID=CREVKEY
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("income")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CREVKEY=lcOldParentID
    pnChildRec=recno()
    pcChildID=CREVKEY
    pcChildExpr="CREVKEY"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CREVKEY",lcParentID,"REVSRC")
  ENDSCAN get all of the income records
  =rireuse("income",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" revsrc
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_sevtax
** "Referential integrity update trigger for" sevtax
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CTABLE")
pcParentID=lcOldParentID
pcParentExpr="CTABLE"
lcParentID=CTABLE
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("wells")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR UPPER(CTABLE)=lcOldParentID
    pnChildRec=recno()
    pcChildID=UPPER(CTABLE)
    pcChildExpr="UPPER(CTABLE)"
    llRetVal=riupdate("CTABLE",substr(lcParentID,1,2),"sevtax")
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
  ENDSCAN get all of the wells records
  =rireuse("wells",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" sevtax
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_taxcodes
** "Referential integrity update trigger for" taxcodes
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CTAXCODE")
pcParentID=lcOldParentID
pcParentExpr="CTAXCODE"
lcParentID=CTAXCODE
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("expcat")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CTAXCODE=lcOldParentID
    pnChildRec=recno()
    pcChildID=CTAXCODE
    pcChildExpr="CTAXCODE"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CTAXCODE",lcParentID,"TAXCODES")
  ENDSCAN get all of the expcat records
  =rireuse("expcat",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" taxcodes
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" vendor
PROCEDURE __RI_DELETE_vendor
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE UPPER(CVENDORID) TO lcParentID,pcParentID
pcParentExpr="UPPER(CVENDORID)"
lcChildWkArea=riopen("expense","cvendorid")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
llRetVal=!SEEK(lcParentID,lcChildWkArea)
SELECT (lcChildWkArea)
pnChildRec=recno()
pcChildID=CVENDORID
pcChildExpr="CVENDORID"
IF !llRetVal
  pnError = rierror(-1,"Delete restrict rule violated.","","")
ENDIF
=rireuse("expense",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE UPPER(CVENDORID) TO lcParentID,pcParentID
pcParentExpr="UPPER(CVENDORID)"
lcChildWkArea=riopen("appmtdet","vendorid")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
llRetVal=!SEEK(lcParentID,lcChildWkArea)
SELECT (lcChildWkArea)
pnChildRec=recno()
pcChildID=CVENDORID
pcChildExpr="CVENDORID"
IF !llRetVal
  pnError = rierror(-1,"Delete restrict rule violated.","","")
ENDIF
=rireuse("appmtdet",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" vendor
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_vendor
** "Referential integrity update trigger for" vendor
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("UPPER(CVENDORID)")
pcParentID=lcOldParentID
pcParentExpr="UPPER(CVENDORID)"
lcParentID=UPPER(CVENDORID)
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("vendexp")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CVENDORID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CVENDORID
    pcChildExpr="CVENDORID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CVENDORID",lcParentID,"VENDOR")
  ENDSCAN get all of the vendexp records
  =rireuse("vendexp",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("UPPER(CVENDORID)")
pcParentID=lcOldParentID
pcParentExpr="UPPER(CVENDORID)"
lcParentID=UPPER(CVENDORID)
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("appurchh")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CVENDORID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CVENDORID
    pcChildExpr="CVENDORID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CVENDORID",lcParentID,"VENDOR")
  ENDSCAN get all of the appurchh records
  =rireuse("appurchh",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("UPPER(CVENDORID)")
pcParentID=lcOldParentID
pcParentExpr="UPPER(CVENDORID)"
lcParentID=UPPER(CVENDORID)
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("appurech")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CVENDORID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CVENDORID
    pcChildExpr="CVENDORID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CVENDORID",lcParentID,"VENDOR")
  ENDSCAN get all of the appurech records
  =rireuse("appurech",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("UPPER(CVENDORID)")
pcParentID=lcOldParentID
pcParentExpr="UPPER(CVENDORID)"
lcParentID=UPPER(CVENDORID)
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("glmaster")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CID
    pcChildExpr="CID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CID",lcParentID,"VENDOR")
  ENDSCAN get all of the glmaster records
  =rireuse("glmaster",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("UPPER(CVENDORID)")
pcParentID=lcOldParentID
pcParentExpr="UPPER(CVENDORID)"
lcParentID=UPPER(CVENDORID)
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("checks")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CID
    pcChildExpr="CID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CID",lcParentID,"VENDOR")
  ENDSCAN get all of the checks records
  =rireuse("checks",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("UPPER(CVENDORID)")
pcParentID=lcOldParentID
pcParentExpr="UPPER(CVENDORID)"
lcParentID=UPPER(CVENDORID)
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("expense")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CVENDORID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CVENDORID
    pcChildExpr="CVENDORID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CVENDORID",lcParentID,"VENDOR")
  ENDSCAN get all of the expense records
  =rireuse("expense",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("UPPER(CVENDORID)")
pcParentID=lcOldParentID
pcParentExpr="UPPER(CVENDORID)"
lcParentID=UPPER(CVENDORID)
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("appmtdet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CVENDORID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CVENDORID
    pcChildExpr="CVENDORID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CVENDORID",lcParentID,"VENDOR")
  ENDSCAN get all of the appmtdet records
  =rireuse("appmtdet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" vendor
********************************************************************************

********************************************************************************
** "Referential integrity delete trigger for" wells
PROCEDURE __RI_DELETE_wells
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcParentWkArea
LOCAL llDelHeaderarea
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
STORE CWELLID TO lcParentID,pcParentID
pcParentExpr="CWELLID"
lcChildWkArea=riopen("leasewell","cwellid")
IF lcChildWkArea<=0
  IF _triggerlevel=1
    DO riend WITH .F.
  ENDIF at the end of the highest trigger level
  RETURN .F.
ENDIF not able to open the child work area
pcChildDBF=dbf(lcChildWkArea)
SELECT (lcChildWkArea)
SEEK lcParentID
SCAN WHILE CWELLID=lcParentID AND llRetVal
  pnChildRec=recno()
  pcChildID=CWELLID
  pcChildExpr="CWELLID"
  llRetVal=ridelete()
ENDSCAN get all of the leasewell records
=rireuse("leasewell",lcChildWkArea)
IF NOT llRetVal
  IF _triggerlevel=1
    DO riend WITH llRetVal
  ENDIF at the end of the highest trigger level
  SELECT (lcStartArea)
  RETURN llRetVal
ENDIF
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Delete trigger for" wells
********************************************************************************

********************************************************************************
procedure __RI_UPDATE_wells
** "Referential integrity update trigger for" wells
LOCAL llRetVal
llRetVal = .t.
PRIVATE pcParentDBF,pnParentRec,pcChildDBF,pnChildRec,pcParentID,pcChildID
PRIVATE pcParentExpr,pcChildExpr
STORE "" TO pcParentDBF,pcChildDBF,pcParentID,pcChildID,pcParentExpr,pcChildExpr
STORE 0 TO pnParentRec,pnChildRec
IF _triggerlevel=1
  BEGIN TRANSACTION
  PRIVATE pcRIcursors,pcRIwkareas,pcRIolderror,pnerror,;
  pcOldDele,pcOldExact,pcOldTalk,pcOldCompat,PcOldDBC
  pcOldTalk=SET("TALK")
  SET TALK OFF
  pcOldDele=SET("DELETED")
  pcOldExact=SET("EXACT")
  pcOldCompat=SET("COMPATIBLE")
  SET COMPATIBLE OFF
  SET DELETED ON
  SET EXACT OFF
  pcRIcursors=""
  pcRIwkareas=""
  pcRIolderror=ON("error")
  pnerror=0
  ON ERROR pnerror=rierror(ERROR(),message(),message(1),program())
  IF TYPE('gaErrors(1)')<>"U"
    release gaErrors
  ENDIF
  PUBLIC gaErrors(1,12)
  pcOldDBC=DBC()
  SET DATA TO ("APPDATA")
ENDIF first trigger
LOCAL lcParentID && parent's value to be sought in child
LOCAL lcOldParentID && previous parent id value
LOCAL lcChildWkArea && child work area handle returned by riopen
LOCAL lcChildID && child's value to be sought in parent
LOCAL lcOldChildID && old child id value
LOCAL lcParentWkArea && parentwork area handle returned by riopen
LOCAL lcStartArea
lcStartArea=select()
llRetVal=.t.
lcParentWkArea=select()
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("welltots")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the welltots records
  =rireuse("welltots",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("metersub")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the metersub records
  =rireuse("metersub",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("deplfile")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the deplfile records
  =rireuse("deplfile",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("appurecd")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CUNITNO=lcOldParentID
    pnChildRec=recno()
    pcChildID=CUNITNO
    pcChildExpr="CUNITNO"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CUNITNO",lcParentID,"WELLS")
  ENDSCAN get all of the appurecd records
  =rireuse("appurecd",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("glmaster")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CUNITNO=lcOldParentID
    pnChildRec=recno()
    pcChildID=CUNITNO
    pcChildExpr="CUNITNO"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CUNITNO",lcParentID,"WELLS")
  ENDSCAN get all of the glmaster records
  =rireuse("glmaster",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("csrctdet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the csrctdet records
  =rireuse("csrctdet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("form6")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the form6 records
  =rireuse("form6",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("workord")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the workord records
  =rireuse("workord",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("expense")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the expense records
  =rireuse("expense",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("expsusp")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the expsusp records
  =rireuse("expsusp",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("incsusp")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the incsusp records
  =rireuse("incsusp",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("susaudit")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the susaudit records
  =rireuse("susaudit",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("glredet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CUNITNO=lcOldParentID
    pnChildRec=recno()
    pcChildID=CUNITNO
    pcChildExpr="CUNITNO"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CUNITNO",lcParentID,"WELLS")
  ENDSCAN get all of the glredet records
  =rireuse("glredet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("afehdr")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the afehdr records
  =rireuse("afehdr",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("invtrans")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the invtrans records
  =rireuse("invtrans",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("income")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the income records
  =rireuse("income",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("stmtnote")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the stmtnote records
  =rireuse("stmtnote",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("roundtmp")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the roundtmp records
  =rireuse("roundtmp",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("disbhist")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the disbhist records
  =rireuse("disbhist",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("appurchd")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CUNITNO=lcOldParentID
    pnChildRec=recno()
    pcChildID=CUNITNO
    pcChildExpr="CUNITNO"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CUNITNO",lcParentID,"WELLS")
  ENDSCAN get all of the appurchd records
  =rireuse("appurchd",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("csdisdet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CUNITNO=lcOldParentID
    pnChildRec=recno()
    pcChildID=CUNITNO
    pcChildExpr="CUNITNO"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CUNITNO",lcParentID,"WELLS")
  ENDSCAN get all of the csdisdet records
  =rireuse("csdisdet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("invdet")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CUNITNO=lcOldParentID
    pnChildRec=recno()
    pcChildID=CUNITNO
    pcChildExpr="CUNITNO"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CUNITNO",lcParentID,"WELLS")
  ENDSCAN get all of the invdet records
  =rireuse("invdet",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("suspense")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the suspense records
  =rireuse("suspense",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("leasewell")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the leasewell records
  =rireuse("leasewell",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("wellhist")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the wellhist records
  =rireuse("wellhist",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("wellinv")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the wellinv records
  =rireuse("wellinv",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("meterdata")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the meterdata records
  =rireuse("meterdata",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
SELECT (lcParentWkArea)
pcParentDBF=dbf()
pnParentRec=recno()
lcOldParentID=OLDVAL("CWELLID")
pcParentID=lcOldParentID
pcParentExpr="CWELLID"
lcParentID=CWELLID
IF lcParentID<>lcOldParentID
  lcChildWkArea=riopen("prepayd")
  IF lcChildWkArea<=0
    IF _triggerlevel=1
      DO riend WITH .F.
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN .F.
  ENDIF not able to open the child work area
  pcChildDBF=dbf(lcChildWkArea)
  SELECT (lcChildWkArea)
  SCAN FOR CWELLID=lcOldParentID
    pnChildRec=recno()
    pcChildID=CWELLID
    pcChildExpr="CWELLID"
    IF NOT llRetVal
      EXIT
    ENDIF && not llretval
    llRetVal=riupdate("CWELLID",lcParentID,"WELLS")
  ENDSCAN get all of the prepayd records
  =rireuse("prepayd",lcChildWkArea)
  IF NOT llRetVal
    IF _triggerlevel=1
      DO riend WITH llRetVal
    ENDIF at the end of the highest trigger level
    SELECT (lcStartArea)
    RETURN llRetVal
  ENDIF
ENDIF this parent id changed
IF _triggerlevel=1
  do riend with llRetVal
ENDIF at the end of the highest trigger level
SELECT (lcStartArea)
RETURN llRetVal
** "End of Referential integrity Update trigger for" wells
********************************************************************************
**__RI_FOOTER!@ Do NOT REMOVE or MODIFY this line!!!! @!__RI_FOOTER**


procedure RIDELETE
local llRetVal
llRetVal=.t.
 IF (ISRLOCKED() and !deleted()) OR !RLOCK()
    llRetVal=.F.
  ELSE
    IF !deleted()
      DELETE
      IF CURSORGETPROP('BUFFERING') > 1
      	=TABLEUPDATE()
      ENDIF
*!*	      llRetVal=pnerror=0
    ENDIF not already deleted
  ENDIF
  UNLOCK RECORD (RECNO())
  llRetVal=pnerror=0
RETURN llRetVal

procedure RIUPDATE
lparameters tcFieldName,tcNewValue,tcCascadeParent
local llRetVal
llRetVal=.t.
 IF ISRLOCKED() OR !RLOCK()
    llRetVal=.F.
  ELSE
    IF EVAL(tcFieldName)<>tcNewValue
      PRIVATE pcCascadeParent
      pcCascadeParent=upper(iif(type("tcCascadeParent")<>"C","",tcCascadeParent))
      REPLACE (tcFieldName) WITH tcNewValue
      IF CURSORGETPROP('BUFFERING') > 1
      	=TABLEUPDATE()
      ENDIF
*!*	      llRetVal=pnerror=0
    ENDIF values don't already match
  ENDIF it's locked already, or I was able to lock it
  UNLOCK RECORD (RECNO())
  llRetVal=pnerror=0
return llRetVal







****@@Begin FoxAudit@@ DO NOT REMOVE OR MODIFY THIS LINE!
******************************************************
* Start of FoxAudit Stored Procedures
******************************************************
FUNCTION FoxAudit
******************************************************
* Author:		Jim Duffy
* Last Revison:	5/22/1999
* Copyright:	1998, 1999 TakeNote Computer Consulting
*				http://www.takenote.com
*				All rights reserved
******************************************************
* Arguments:
*	tcKey - the key value for the record (optional)
*       If empty, FoxAudit will figure it out based
*       on the primary key index
*	tcObject - the name of the FoxAudit object to use (optional)
*       If empty, FoxAudit will use "o" plus the name
*       of the DBC the table is contained in
*	tcLogLocation - the transaction log to use (optional)
*       If empty, FoxAudit will use the name of the DBC
*       plus "_LOG"
*	tcTag - the Primary index tag name (optional)
*       This only needs to be specified if there is not a
*       primary index tag for the table. tcTag is the name
*       of the index tag that makes a record unique.
*
* Examples:
* 	FoxAudit()		(Most common technique used)
* 	FoxAudit(,"oFoxAudit","C:\Log\MyLog.dbf","Cust_ID")
*
******************************************************
LPARAMETERS ;
	tcKey, ;
	tcObject, ;
	tcLogLocation, ;
	tcTag

******************************************************
* Declare LOCAL variables
******************************************************
LOCAL ;
	llReturnValue, ;
	lcMsgText, ;
	lcDbc, ;
	lcObject, ;
	lcLogLocation, ;
	liDataSession, ;
	lcFieldState, ;
	lnArea, ;
	lcCmd, ;
	lnKount, ;
	lnTags, ;
	lcTrigger, ;
	llStoredProc, ;
	lcKey
	
llReturnValue = .T.
STORE '' TO lcKey, lcTag

******************************************************
* Determine Key Value
******************************************************
TRY

lnArea = SELECT()
IF EMPTY(tcKey)
	lnTags = TAGCOUNT( "", lnArea)

	FOR lnKount = 1 TO lnTags
		IF PRIMARY(lnKount,lnArea)
			EXIT
		ENDIF
	ENDFOR
	lcKey = EVAL(SYS(14,lnKount,lnArea))
ELSE
	lcKey = tcKey	
ENDIF
CATCH TO loerror
   lcalias = ALIAS()
   MESSAGEBOX('Error: ' + loerror.message + CHR(13) + ;
              'Alias: ' + lcAlias,64,'Foxaudit')
   lcKey = tcKey
ENDTRY

******************************************************
* Determine Trigger Type
******************************************************
lcFieldState = GETFLDSTATE(-1)
DO CASE
	CASE LEFT(lcFieldState,1) = "2" AND DELETED()
		lcTrigger = "D"

	CASE LEFT(lcFieldState,1) = "2" AND ! DELETED()
		lcTrigger = "I"

	CASE "3" $ lcFieldState OR "4" $ lcFieldState
		lcTrigger = "I"

	CASE "2" $ lcFieldState
		lcTrigger = "U"
ENDCASE

******************************************************
* Determine the index tag
******************************************************
IF EMPTY(tcTag)
	FOR i = 1 TO TAGCOUNT()
		IF PRIMARY(i)
			lcTag = TAG(i)
			EXIT
		ENDIF
	ENDFOR
ELSE
	lcTag = tcTag
ENDIF

******************************************************
* Determine name of the DBC
******************************************************
lcDbc	= JustStem(ALLTRIM(CURSORGETPROP("DATABASE")))

******************************************************
* Determine current datasession
******************************************************
liDataSession = SET("DATASESSION")

******************************************************
* If the tcObject parameter is omitted, FOXAUDIT will
* use "oFoxAudit_" plus the name of the current DBC as
* the name of the FoxAudit object to use.
*
* For example, if the name of the current database
* is TestData and the tcObject is ommitted, FOXAUDIT
* will use oFoxAudit_TestData as the name of the FoxAudit
* object.
******************************************************
IF EMPTY(tcObject)
	lcObject		= "oFoxAudit_"+lcDbc
ELSE
	lcObject		= ALLTRIM(tcObject)
ENDIF

******************************************************
* If the tcLogLocation parameter is omitted, FOXAUDIT
* use the name of the database plus "_LOG" as the name
* of the transaction log.  FoxAudit will look for that
* log in the same directory as the table being updated.
******************************************************
IF EMPTY(tcLogLocation)
	lcLogLocation = JustPath(DBF())+"\"+lcDbc+"_LOG.DBF"
ELSE
	lcLogLocation		= ALLTRIM(tcLogLocation)
ENDIF

******************************************************
* Determine if the FoxAudit classlib needs to be
* loaded. During an interactive record change, via
* the Browse window for example, a FoxAudit object
* will be created if necessary.
******************************************************
IF NOT ("FOXAUDIT" $ UPPER(SET("CLASSLIB")))
	SET CLASSLIB TO custom\FOXAUDIT ADDITIVE
ENDIF

******************************************************
* If the specified FoxAudit object does not exist then
* one will be created. The llStoredProc flag will be
* set indicating the FoxAudit object was built it the
* stored procedure code
******************************************************
llStoredProc = .F.
IF TYPE(lcObject) <> "O"
	PUBLIC (lcObject)
	lcCmd = lcObject+" = CREATEOBJECT('FOXAUDIT',lcLogLocation)"
	&lcCmd.
	llStoredProc = .T.
ENDIF

******************************************************
* LogUpdates method accepts the key, trigger,
* datasessionID and the index tag to use.
******************************************************
IF TYPE(lcObject) == "O" AND NOT ISNULL(lcObject)
* LogUpdates returns .T. if transaction was sucessfully logged. It
* returns .F. if it doesn't. One reason LoUpdates could return .F.
* is if the PreLogUpdatesHook returns .F., thus cancelling the
* update.
	IF llStoredProc
		lcCmd = lcObject+".cUserMsg1 = [Updated via interactive change]"
		&lcCmd.
	ENDIF

	lcCmd = lcObject+".LogUpdates(lcKey,lcTrigger,liDataSession,lcTag)"
	IF NOT &lcCmd.
		lcMsgText = "FoxAudit  was unable to log the current transaction. The LogUpdates "
		lcMsgText = lcMsgText + "method RETURNed .F. "
		=MESSAGEBOX(lcMsgText,0,"FoxAudit 6.0 LogUpdates Problem")
		RETURN(.F.)	&& LogUpdates returning .F. causes trigger to fail
	ENDIF
ELSE
	llReturnValue = .F.
ENDIF

IF ! llReturnValue
	IF !FILE(lcLogLocation)
		LOCAL lcMsgText
		lcMsgText = "Transaction log table: "+ALLTRIM(lcLogLocation)+CHR(13)+CHR(13)
		lcMsgText = lcMsgText + "The above transaction log table does not exist. Normally FoxAudit 6.0 would "
		lcMsgText = lcMsgText + "build the transaction "
		lcMsgText = lcMsgText + "log for you.  The exception in this case is that an update was in progress and "
		lcMsgText = lcMsgText + "Visual FoxPro does not allow the creation of a table inside of a trigger "
		lcMsgText = lcMsgText + "call. Use the FoxAudit 6.0 DBC Setup wizard "
		lcMsgText = lcMsgText + "to create a transaction log table or create a FoxAudit 6.0 object outside "
		lcMsgText = lcMsgText + "of a trigger call."
	ELSE
		LOCAL lcMsgText
		lcMsgText = "FoxAudit 6.0 Problem. The oFoxAudit object was not created."
	ENDIF

	=MESSAGEBOX(lcMsgText,0,"FoxAudit 6.0 Error")
ENDIF

RETURN(llReturnValue)


*************************************
* End of FoxAudit Stored Procedures *
*************************************
****@@End FoxAudit@@ DO NOT REMOVE OR MODIFY THIS LINE!
                            N <   %   <        |           U  H    > BCCC  C"   ~!@#$%^&()_+|-`=\:;,./<>'  fC  > U  CSTRING   #          T   !  (CC  `>4 T C C  >  . C   \6+ %C 9 C    *? %C   T   J-(   T   C   %C 
# T C     \ % 
 T C @ T C  ci Se T C  ce Se T C  cy Se T C  cae Se T C  cz S T C  tch S T C  wr R T C  ph F T C  qu KW T C  ge Je T C  gy Je T C  gi Je T C  gn N T C  kn N T C  dn N% T C  cvmdzp KFNTSB HH C = x! T C  x S C = ps" T C  ps S C = pt" T C  pt T  %C `Q T CCC = aeiouyhw AAAAAAAAfCC > C \   6 A T CC = g GCC > C \   6  T C  gh   T C  x KS  T     T     J  (     (C > T C  \. %C f 
   aeiouyhw
	 T  C f  T C f  BC C  > U	 	 CINSTRING IX CH CLASTCH NSTART	 LHASDIGIT CTEMPBUFFER CRESULT CWORD     T  a %C C'
	 CS
9  T  -   %C'
|   %C	 BUFFERINGx 	 C   
 Z#CO T    	 B   U  LLRETVAL PNERROR         T a %C CS
@  T -   %C     5 3 T CCC tcCascadeParentb C     6f >    %C	 BUFFERING 	 C   
 Z#CO T   	 B  U  TCFIELDNAME
 TCNEWVALUE TCCASCADEPARENT LLRETVAL PCCASCADEPARENT PNERROR' 4         T C + %C gaErrors[lnErrorRows,1]b L    C  T    T     T    T    T     T  +CC t
O, T  C    ,C t T    T    T    T  	  T  
  T  	  T  
  T    T   	 B   U  TNERRNO	 TCMESSAGE TCCODE	 TCPROGRAM LNERRORROWS LNXX GAERRORS PCPARENTDBF PNPARENTREC
 PCPARENTID PCPARENTEXPR
 PCCHILDDBF
 PNCHILDREC	 PCCHILDID PCCHILDEXPRV 4          T   T CC  f *C f  (   T C   *  0 %CC  \ CC  \  !  T    %   T CW F   T CW %C 
*% Q   __riCCCWZA  P Q   __riCCCWZA  %    T  C  f ?CCWZ  T    E! T CC  C  >\g5 T C C  f *C ZC  f ?C Z %C 
 G( (   %  A T    
 B  U	  TCTABLE TCORDER LCCURWKAREA LCNEWWKAREA LNINUSESPOT LNOCCURS LNOCCURANCE PCRICURSORS PNERROR 4       %  (   @  G  G   %C [  {   ~  ON ERROR &pcRIolderror.
   (C *   T C *   QCC  \g  %  ON  GA   %  OFF	 G  %  ON& G   %	  ONC G2   HT C
 i G( 
 C G(
   Ba U 	 TLSUCCESS LNXX LNSPOT
 LCWORKAREA PCRIOLDERROR PCRICURSORS PCOLDCOMPAT	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDDBCJ  4   5 T C C  f ?C ZC  f *C Z Ba U  TCTABLENAME TCWKAREA PCRICURSORS    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CIDAFEH! T C afedet cidafeh  %   %=  -  B-  T C &
 F 	 E  ~+     	O T CO T   T  CIDAFEH T  C   C afedet    %  
 %=     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CIDAFEH RIOPEN RIEND RIDELETE RIREUSEC    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CIDAFEH_ T   T  CIDAFEH T   %  
 T C afedet  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CIDAFEH %  
 ! % T  C CIDAFEH   AFEHDR   C afedet    %  
 %=     
 F 	 B     %=)     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CIDAFEH RIOPEN RIEND RIUPDATE RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CBATCH" T C appmtdet cbatch  %   %=  -  B-  T C &
 F 	 E  ~+     	N T CO T   T  CBATCH T  C   C appmtdet    %  
 %=     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CBATCH RIOPEN RIEND RIDELETE RIREUSEE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CBATCH_ T   T  CBATCH T   %   T C appmtdet  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CBATCH %  
 ! & T  C CBATCH   APPMTHDR   C appmtdet    %  
 %=     
 F 	 B     %=+     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CBATCH RIOPEN RIEND RIUPDATE RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CBATCH" T C appurchd cbatch  %   %=  -  B-  T C &
 F 	 E  ~+     	N T CO T   T  CBATCH T  C   C appurchd    %  
 %=     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CBATCH RIOPEN RIEND RIDELETE RIREUSEE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CBATCH_ T   T  CBATCH T   %   T C appurchd  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CBATCH %  
 ! & T  C CBATCH   APPURCHH   C appurchd    %  
 %=     
 F 	 B     %=+     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CBATCH RIOPEN RIEND RIUPDATE RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CBATCH" T C appurecd cbatch  %   %=  -  B-  T C &
 F 	 E  ~+     	N T CO T   T  CBATCH T  C   C appurecd    %  
 %=     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CBATCH RIOPEN RIEND RIDELETE RIREUSEE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CBATCH_ T   T  CBATCH T   %   T C appurecd  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CBATCH %  
 ! & T  C CBATCH   APPURECH   C appurecd    %  
 %=     
 F 	 B     %=+     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CBATCH RIOPEN RIEND RIUPDATE RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CACCTNO" T C glmaster acctno  %   %=  -  B-  T C & T  C  

 F  T CO T   T  CACCTNO %  
z9 T C Delete restrict rule violated.       C glmaster    %  
 %=     
 F 	 B   
 F  T C& T CO J (   T  CACCTNO! T C checks cacctno  %  z %=o  -  B-  T C & T  C  

 F  T CO T   T  CACCTNO %  
9 T C Delete restrict rule violated.       C checks    %  
y %=b     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CACCTNO RIOPEN RIEND RIERROR RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CACCTNO_ T   T  CACCTNO T   %   T C glmaster  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CACCTNO %  
 ! " T  C CACCTNO   COA   C glmaster    %  
 %=     
 F 	 B    
 F  T C& T CO T C CACCTNO_ T   T  CACCTNO T   %   T C appurecd  %   %=  - 
 F  B-  T C &
 F  ~  u T CO T   T  CACCTNO %  
O ! " T  C CACCTNO   COA   C appurecd    %  
 %=     
 F 	 B    
 F  T C& T CO T C CACCTNO_ T   T  CACCTNO T   %   T C checks  %   %=  - 
 F  B-  T C &
 F  ~  > T CO T   T  CACCTNO %  
 ! " T  C CACCTNO   COA   C checks    %  
 %=     
 F 	 B    
 F  T C& T CO T C CACCTNO_ T   T  CACCTNO T   %  h	 T C appurchd  %  s %=^  - 
 F  B-  T C &
 F  ~  	 T CO T   T  CACCTNO %  
 ! " T  C CACCTNO   COA   C appurchd    %  
d	 %=M	     
 F 	 B    
 F  T C& T CO T C CACCTNO_ T   T  CACCTNO T   %  / T C invdet  %  <
 %='
  - 
 F  B-  T C &
 F  ~  
 T CO T   T  CACCTNO %  

 ! " T  C CACCTNO   COA   C invdet    %  
+ %=     
 F 	 B    
 F  T C& T CO T C CACCTNO_ T   T  CACCTNO T   %   T C expcat  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CCRACCTO %  
r ! # T  C CCRACCTO   COA   C expcat    %  
 %=     
 F 	 B    
 F  T C& T CO T C CACCTNO_ T   T  CACCTNO T   %   T C expcat  %   %=  - 
 F  B-  T C &
 F  ~   b T CO T    T  CCRACCTV %  
; ! # T  C CCRACCTV   COA   C expcat    %  
 %=     
 F 	 B    
 F  T C& T CO T C CACCTNO_ T   T  CACCTNO T   %   T C expcat  %   %=  - 
 F  B-  T C &
 F  ~!  + T CO T !  T  CDRACCTO %  
 ! # T  C CDRACCTO   COA   C expcat    %  
 %=o     
 F 	 B    
 F  T C& T CO T C CACCTNO_ T   T  CACCTNO T   %  S T C expcat  %  ^ %=I  - 
 F  B-  T C &
 F  ~"   T CO T "  T  CDRACCTV %  
 ! # T  C CDRACCTV   COA   C expcat    %  
O %=8     
 F 	 B     %=r     
 F 	 B   U#  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CACCTNO RIOPEN RIEND RIUPDATE RIREUSE CCRACCTO CCRACCTV CDRACCTO CDRACCTV    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CBATCH" T C csdisdet cbatch  %   %=  -  B-  T C &
 F 	 E  ~+     	N T CO T   T  CBATCH T  C   C csdisdet    %  
 %=     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CBATCH RIOPEN RIEND RIDELETE RIREUSEE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CBATCH_ T   T  CBATCH T   %   T C csdisdet  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CBATCH %  
 ! & T  C CBATCH   CSDISHDR   C csdisdet    %  
 %=     
 F 	 B     %=+     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CBATCH RIOPEN RIEND RIUPDATE RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CBATCH" T C csrctdet cbatch  %   %=  -  B-  T C &
 F 	 E  ~+     	N T CO T   T  CBATCH T  C   C csrctdet    %  
 %=     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CBATCH RIOPEN RIEND RIDELETE RIREUSEE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CBATCH_ T   T  CBATCH T   %   T C csrctdet  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CBATCH %  
 ! & T  C CBATCH   CSRCTHDR   C csrctdet    %  
 %=     
 F 	 B     %=+     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CBATCH RIOPEN RIEND RIUPDATE RIREUSE	    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C UPPER(CCUSTID)_ T   T  UPPER(CCUSTID) T C f %   T C invhdr  %  $ %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CCUSTID %  
 ! $ T  C CCUSTID   CUSTS   C invhdr    %  
 %=     
 F 	 B    
 F  T C& T CO T C UPPER(CCUSTID)_ T   T  UPPER(CCUSTID) T C f %   T C glmaster  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CID %  
i !   T  C CID   CUSTS   C glmaster    %  
 %=     
 F 	 B    
 F  T C& T CO T C UPPER(CCUSTID)_ T   T  UPPER(CCUSTID) T C f %   T C arpmthdr  %   %=  - 
 F  B-  T C &
 F  ~  j T CO T   T  CCUSTID %  
B ! $ T  C CCUSTID   CUSTS   C arpmthdr    %  
 %=     
 F 	 B    
 F  T C& T CO T C UPPER(CCUSTID)_ T   T  UPPER(CCUSTID) T C f %  	 T C checks  %   %=  - 
 F  B-  T C &
 F  ~  =	 T CO T   T  CID %  
	 !   T  C CID   CUSTS   C checks    %  
	 %=	     
 F 	 B     %=	     
 F 	 B   U   LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CCUSTID RIOPEN RIEND RIUPDATE RIREUSE CID    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CBATCH" T C depositd cbatch  %   %=  -  B-  T C &
 F 	 E  ~+     	N T CO T   T  CBATCH T  C   C depositd    %  
 %=     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CBATCH RIOPEN RIEND RIDELETE RIREUSEE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CBATCH_ T   T  CBATCH T   %   T C depositd  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CBATCH %  
 ! & T  C CBATCH   DEPOSITS   C depositd    %  
 %=     
 F 	 B     %=+     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CBATCH RIOPEN RIEND RIUPDATE RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CDISPERM_ T   T  CDISPERM T   %   T C brinelog  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CDISPERM %  
 ! ( T  C CDISPERM   DISPOSAL   C brinelog    %  
 %=     
 F 	 B    
 F  T C& T CO T C CDISPERM_ T   T  CDISPERM T   %   T C items  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CDISPERM %  
X ! ( T  C CDISPERM   DISPOSAL   C items    %  
 %=     
 F 	 B     %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CDISPERM RIOPEN RIEND RIUPDATE RIREUSE
    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CEMPID  T C prdata cempid  %   %=  -  B-  T C & T  C  

 F  T CO T   T  CEMPID %  
v9 T C Delete restrict rule violated.       C prdata    %  
 %=     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CEMPID RIOPEN RIEND RIERROR RIREUSEK    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CEMPID_ T   T  CEMPID T   %   T C glmaster  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CID %  
~ !  T  C CID   EMPS   C glmaster    %  
 %=     
 F 	 B    
 F  T C& T CO T C CEMPID_ T   T  CEMPID T   %   T C prdata  %   %=  - 
 F  B-  T C &
 F  ~  g T CO T   T  CEMPID %  
A ! " T  C CEMPID   EMPS   C prdata    %  
 %=     
 F 	 B    
 F  T C& T CO T C CEMPID_ T   T  CEMPID T   %   T C premptax  %   %=  - 
 F  B-  T C &
 F  ~  - T CO T   T  CEMPID %  
 ! " T  C CEMPID   EMPS   C premptax    %  
 %=s     
 F 	 B    
 F  T C& T CO T C CEMPID_ T   T  CEMPID T   %  T	 T C prcodes  %  a %=L  - 
 F  B-  T C &
 F  ~   T CO T   T  CEMPID %  
 ! " T  C CEMPID   EMPS   C prcodes    %  
P	 %=9	     
 F 	 B    
 F  T C& T CO T C CEMPID_ T   T  CEMPID T   %   T C checks  %  &
 %=
  - 
 F  B-  T C &
 F  ~  
 T CO T   T  CID %  

 !  T  C CID   EMPS   C checks    %  
 %=
     
 F 	 B     %=1     
 F 	 B   U   LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CEMPID RIOPEN RIEND CID RIUPDATE RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CCATCODE_ T   T  CCATCODE T   %   T C expense  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CCATCODE %  
 ! & T  C CCATCODE   EXPCAT   C expense    %  
 %=     
 F 	 B    
 F  T C& T CO T C CCATCODE_ T   T  CCATCODE T   %   T C expsusp  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CCATCODE %  
V ! & T  C CCATCODE   EXPCAT   C expsusp    %  
 %=     
 F 	 B    
 F  T C& T CO T C CCATCODE_ T   T  CCATCODE T   %   T C glmaster  %   %=  - 
 F  B-  T C &
 F  ~  Q T CO T   T  CCATCODE %  
' ! & T  C CCATCODE   EXPCAT   C glmaster    %  
 %=     
 F 	 B    
 F  T C& T CO T C CCATCODE_ T   T  CCATCODE T   %  	 T C appurecd  %   %=u  - 
 F  B-  T C &
 F  ~  #	 T CO T   T  CCATCODE %  
 ! & T  C CCATCODE   EXPCAT   C appurecd    %  
	 %=i	     
 F 	 B    
 F  T C& T CO T C CCATCODE_ T   T  CCATCODE T   %  V T C appurchd  %  \
 %=G
  - 
 F  B-  T C &
 F  ~  
 T CO T   T  CCATCODE %  

 ! & T  C CCATCODE   EXPCAT   C appurchd    %  
R %=;     
 F 	 B    
 F  T C& T CO T C CCATCODE_ T   T  CCATCODE T   %  " T C csrctdet  %  . %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CTYPE %  
 ! # T  C CTYPE   EXPCAT   C csrctdet    %  
 %=     
 F 	 B    
 F  T C& T CO T C CCATCODE_ T   T  CCATCODE T   %   T C afeowner  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CCATCODE %  
i ! & T  C CCATCODE   EXPCAT   C afeowner    %  
 %=     
 F 	 B    
 F  T C& T CO T C CCATCODE_ T   T  CCATCODE T   %   T C afedet  %   %=  - 
 F  B-  T C &
 F  ~  c T CO T   T  CCATCODE %  
9 ! & T  C CCATCODE   EXPCAT   C afedet    %  
 %=     
 F 	 B     %=     
 F 	 B   U   LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CCATCODE RIOPEN RIEND RIUPDATE RIREUSE CTYPE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CMETERNO_ T   T  CMETERNO T   %   T C gasinv  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CMETERNO %  
 ! & T  C CMETERNO   GASOWN   C gasinv    %  

 %=     
 F 	 B    
 F  T C& T CO T C CMETERNO_ T   T  CMETERNO T   %   T C gasuse  %   %=  - 
 F  B-  T C &
 F  ~  } T CO T   T  CMETERNO %  
S ! & T  C CMETERNO   GASOWN   C gasuse    %  
 %=     
 F 	 B    
 F  T C& T CO T C CMETERNO_ T   T  CMETERNO T   %   T C gasuse  %   %=  - 
 F  B-  T C &
 F  ~   c T CO T    T  CMETERNO+COWNERID- T  C CMETERNOC \ gasown  %  
_ !   C gasuse    %  
 %=     
 F 	 B     %=     
 F 	 B   U   LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CMETERNO RIOPEN RIEND RIUPDATE RIREUSE COWNERID    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CBATCH  T C glredet batch  %   %=  -  B-  T C &
 F 	 E  ~+     	L T CO T   T  CBATCH T  C   C glredet    %  
 %=     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CBATCH RIOPEN RIEND RIDELETE RIREUSEB    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CBATCH_ T   T  CBATCH T   %  	 T C glredet  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CBATCH %  
 ! % T  C CBATCH   GLRECUR   C glredet    %  
 %=     
 F 	 B     %=(     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CBATCH RIOPEN RIEND RIUPDATE RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CGROUP_ T   T  CGROUP T   %  
 T C suspense  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CGROUP %  
 ! $ T  C CGROUP   GROUPS   C suspense    %  
 %=     
 F 	 B    
 F  T C& T CO T C CGROUP_ T   T  CGROUP T   %   T C wells  %   %=  - 
 F  B-  T C &
 F  ~C f  T CO T C f T  UPPER(CGROUP)+ T  C CGROUPC \ groups  %  
~ !   C wells    %  
 %=     
 F 	 B     %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CGROUP RIOPEN RIEND RIUPDATE RIREUSE*    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %   T C susaudit  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  COWNERID %  
 ! ( T  C COWNERID   INVESTOR   C susaudit    %  
 %=     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %   T C invhdr  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CCUSTID %  
X ! ' T  C CCUSTID   INVESTOR   C invhdr    %  
 %=     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %   T C checks  %   %=  - 
 F  B-  T C &
 F  ~   I T CO T    T  CID %  
" ! # T  C CID   INVESTOR   C checks    %  
 %=     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %  |	 T C disbhist  %   %=k  - 
 F  B-  T C &
 F  ~  	 T CO T   T  COWNERID %  
 ! ( T  C COWNERID   INVESTOR   C disbhist    %  
x	 %=a	     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %  P T C csdisdet  %  T
 %=?
  - 
 F  B-  T C &
 F  ~  
 T CO T   T  COWNERID %  

 ! ( T  C COWNERID   INVESTOR   C csdisdet    %  
L %=5     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %  $ T C appurchd  %  ( %=  - 
 F  B-  T C &
 F  ~   T CO T   T  COWNERID %  
 ! ( T  C COWNERID   INVESTOR   C appurchd    %  
  %=	     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %   T C expense  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  COWNERID %  
j ! ( T  C COWNERID   INVESTOR   C expense    %  
 %=     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %   T C incsusp  %   %=  - 
 F  B-  T C &
 F  ~  h T CO T   T  COWNERID %  
< ! ( T  C COWNERID   INVESTOR   C incsusp    %  
 %=     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %   T C expsusp  %   %=  - 
 F  B-  T C &
 F  ~  : T CO T   T  COWNERID %  
 ! ( T  C COWNERID   INVESTOR   C expsusp    %  
 %=     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %  n T C csrctdet  %  r %=]  - 
 F  B-  T C &
 F  ~   T CO T   T  COWNERID %  
 ! ( T  C COWNERID   INVESTOR   C csrctdet    %  
j %=S     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %  B T C landhist  %  F %=1  - 
 F  B-  T C &
 F  ~   T CO T   T  COWNERID %  
 ! ( T  C COWNERID   INVESTOR   C landhist    %  
> %='     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %   T C	 landowner  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  COWNERID %  
 ! ( T  C COWNERID   INVESTOR   C	 landowner    %  
 %=     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %   T C suspense  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  COWNERID %  
_ ! ( T  C COWNERID   INVESTOR   C suspense    %  
 %=     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %   T C glmaster  %   %=  - 
 F  B-  T C &
 F  ~   U T CO T    T  CID %  
. ! # T  C CID   INVESTOR   C glmaster    %  
 %=     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %  ~ T C tax1099  %   %=x  - 
 F  B-  T C &
 F  ~    T CO T    T  CID %  
 ! # T  C CID   INVESTOR   C tax1099    %  
z %=c     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %  P T C prepayh  %  U %=@  - 
 F  B-  T C &
 F  ~   T CO T   T  COWNERID %  
 ! ( T  C COWNERID   INVESTOR   C prepayh    %  
L %=5     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %  "! T C prepayd  %  '  %=   - 
 F  B-  T C &
 F  ~    T CO T   T  COWNERID %  
  ! ( T  C COWNERID   INVESTOR   C prepayd    %  
! %=!     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %  " T C arpmthdr  %  ! %=!  - 
 F  B-  T C &
 F  ~  " T CO T   T  CCUSTID %  
h" ! ' T  C CCUSTID   INVESTOR   C arpmthdr    %  
" %="     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %  $ T C gasuse  %  # %=#  - 
 F  B-  T C &
 F  ~  e$ T CO T   T  COWNERID %  
9$ ! ( T  C COWNERID   INVESTOR   C gasuse    %  
$ %=$     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %  & T C gasown  %  % %=%  - 
 F  B-  T C &
 F  ~ !  M& T CO T  !  T  COWNERID+CMETERNO/ T  C COWNERIDC 
\ investor  %  
I& !   C gasown    %  
& %=&     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %  ~( T C arpmtdet  %  ' %=o'  - 
 F  B-  T C &
 F  ~  ( T CO T   T  CCUSTID %  
' ! ' T  C CCUSTID   INVESTOR   C arpmtdet    %  
z( %=c(     
 F 	 B    
 F  T C& T CO T C COWNERID_ T   T  COWNERID T   %  P* T C wellinv  %  U) %=@)  - 
 F  B-  T C &
 F  ~  ) T CO T   T  COWNERID %  
) ! ( T  C COWNERID   INVESTOR   C wellinv    %  
L* %=5*     
 F 	 B     %=o*     
 F 	 B   U"  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA COWNERID RIOPEN RIEND RIUPDATE RIREUSE CCUSTID CID CMETERNO    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CBATCH  T C invdet cbatch  %   %=  -  B-  T C &
 F 	 E  ~+     	L T CO T   T  CBATCH T  C   C invdet    %  
 %=     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CBATCH RIOPEN RIEND RIDELETE RIREUSE?    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CBATCH_ T   T  CBATCH T   %   T C invdet  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CBATCH %  
 ! $ T  C CBATCH   INVHDR   C invdet    %  
 %=     
 F 	 B     %=%     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CBATCH RIOPEN RIEND RIUPDATE RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CBATCH! T C invrecd cbatch  %   %=  -  B-  T C &
 F 	 E  ~+     	M T CO T   T  CBATCH T  C   C invrecd    %  
 %=     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CBATCH RIOPEN RIEND RIDELETE RIREUSEB    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CBATCH_ T   T  CBATCH T   %  	 T C invrecd  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CBATCH %  
 ! % T  C CBATCH   INVRECH   C invrecd    %  
 %=     
 F 	 B     %=(     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CBATCH RIOPEN RIEND RIUPDATE RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CITEMID! T C invdet citemid  %   %=  -  B-  T C & T  C  

 F  T CO T   T  CITEMID %  
y9 T C Delete restrict rule violated.       C invdet    %  
 %=     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CITEMID RIOPEN RIEND RIERROR RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CITEMID_ T   T  CITEMID T   %  	 T C invdet  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CITEMID %  
 ! $ T  C CITEMID   ITEMS   C invdet    %  
 %=     
 F 	 B    
 F  T C& T CO T C CITEMID_ T   T  CITEMID T   %   T C invtrans  %   %=  - 
 F  B-  T C &
 F  ~  u T CO T   T  CITEMID %  
M ! $ T  C CITEMID   ITEMS   C invtrans    %  
 %=     
 F 	 B    
 F  T C& T CO T C CITEMID_ T   T  CITEMID T   %   T C appurecd  %   %=  - 
 F  B-  T C &
 F  ~  B T CO T   T  CITEMID %  
 ! $ T  C CITEMID   ITEMS   C appurecd    %  
 %=     
 F 	 B     %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CITEMID RIOPEN RIEND RIUPDATE RIREUSEm    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CLEASEID% T C	 landowner cleaseid  %   %=  -  B-  T C &
 F 	 E  ~+     	U T CO T   T  CLEASEID T  C   C	 landowner    %  
 %=     
 F 	 B   
 F  T C& T CO J (   T  CLEASEID% T C	 leasewell cleaseid  %  [ %=P  -  B-  T C &
 F 	 E  ~+     	 T CO T   T  CLEASEID T  C   C	 leasewell    %  
4 %=     
 F 	 B    %=S     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CLEASEID RIOPEN RIEND RIDELETE RIREUSE	    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CLEASEID_ T   T  CLEASEID T   %   T C landhist  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CLEASEID %  
 ! $ T  C CLEASEID   LAND   C landhist    %  
 %=     
 F 	 B    
 F  T C& T CO T C CLEASEID_ T   T  CLEASEID T   %   T C	 landowner  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CLEASEID %  
X ! $ T  C CLEASEID   LAND   C	 landowner    %  
 %=     
 F 	 B    
 F  T C& T CO T C CLEASEID_ T   T  CLEASEID T   %   T C	 leasewell  %   %=  - 
 F  B-  T C &
 F  ~  R T CO T   T  CLEASEID %  
* ! $ T  C CLEASEID   LAND   C	 leasewell    %  
 %=     
 F 	 B    
 F  T C& T CO T C CLEASEID_ T   T  CLEASEID T   %  	 T C wells  %   %=t  - 
 F  B-  T C &
 F  ~C f 2	 T CO T C f T  UPPER(CLEASEID)+ T  C CLEASEIDC 
\ land  %  
.	 !   C wells    %  
	 %=u	     
 F 	 B     %=	     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CLEASEID RIOPEN RIEND RIUPDATE RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CBATCH" T C metersub cbatch  %   %=  -  B-  T C &
 F 	 E  ~+     	N T CO T   T  CBATCH T  C   C metersub    %  
 %=     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CBATCH RIOPEN RIEND RIDELETE RIREUSEE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CBATCH_ T   T  CBATCH T   %   T C metersub  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CBATCH %  
 ! & T  C CBATCH   METERALL   C metersub    %  
 %=     
 F 	 B     %=+     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CBATCH RIOPEN RIEND RIUPDATE RIREUSE	    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CMETERID_ T   T  CMETERID T   %   T C metersub  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CMETERID %  
 ! & T  C CMETERID   METERS   C metersub    %  
 %=     
 F 	 B    
 F  T C& T CO T C CMETERID_ T   T  CMETERID T   %   T C meterall  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CMETERID %  
Y ! & T  C CMETERID   METERS   C meterall    %  
 %=     
 F 	 B    
 F  T C& T CO T C CMETERID_ T   T  CMETERID T   %   T C	 meterdata  %   %=  - 
 F  B-  T C &
 F  ~  V T CO T   T  CMETERID %  
, ! & T  C CMETERID   METERS   C	 meterdata    %  
 %=     
 F 	 B    
 F  T C& T CO T C CMETERID_ T   T  CMETERID T   %  	 T C wells  %   %=x  - 
 F  B-  T C &
 F  ~C f 8	 T CO T C f T  UPPER(CMETERID)- T  C CMETERIDC \ meters  %  
4	 !   C wells    %  
	 %={	     
 F 	 B     %=	     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CMETERID RIOPEN RIEND RIUPDATE RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CBATCH" T C proghstd cbatch  %   %=  -  B-  T C &
 F 	 E  ~+     	N T CO T   T  CBATCH T  C   C proghstd    %  
 %=     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CBATCH RIOPEN RIEND RIDELETE RIREUSEE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CBATCH_ T   T  CBATCH T   %   T C proghstd  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CBATCH %  
 ! & T  C CBATCH   PROGHSTH   C proghstd    %  
 %=     
 F 	 B     %=+     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CBATCH RIOPEN RIEND RIUPDATE RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T 	 CPROGCODE$ T C progrel	 cprogcode  %   %=  -  B-  T C &
 F 	 E  ~+     	V T CO T   T 	 CPROGCODE T  C   C progrel    %  
 %=     
 F 	 B   
 F  T C& T CO J (   T 	 CPROGCODE% T C proghsth	 cprogcode  %  [ %=P  -  B-  T C & T  C  

 F  T CO T   T 	 CPROGCODE %  
9 T C Delete restrict rule violated.       C proghsth    %  
^ %=G     
 F 	 B    %=}     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA	 CPROGCODE RIOPEN RIEND RIDELETE RIREUSE RIERROR    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C	 CPROGCODE_ T   T 	 CPROGCODE T   %   T C progrel  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T 	 CPROGCODE %  
 ! ) T  C	 CPROGCODE   PROGRAMS   C progrel    %  
 %=     
 F 	 B    
 F  T C& T CO T C	 CPROGCODE_ T   T 	 CPROGCODE T   %   T C proghsth  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T 	 CPROGCODE %  
` ! ) T  C	 CPROGCODE   PROGRAMS   C proghsth    %  
 %=     
 F 	 B    
 F  T C& T CO T C	 CPROGCODE_ T   T 	 CPROGCODE T   %   T C form1065  %   %=  - 
 F  B-  T C &
 F  ~  e T CO T   T 	 CPROGCODE %  
8 ! ) T  C	 CPROGCODE   PROGRAMS   C form1065    %  
 %=     
 F 	 B    
 F  T C& T CO T C	 CPROGCODE_ T   T 	 CPROGCODE T   %  	 T C k1file  %   %=  - 
 F  B-  T C &
 F  ~  ;	 T CO T   T 	 CPROGCODE %  
	 ! ) T  C	 CPROGCODE   PROGRAMS   C k1file    %  
	 %=	     
 F 	 B    
 F  T C& T CO T C	 CPROGCODE_ T   T 	 CPROGCODE T   %  p T C wellinv  %  s
 %=^
  - 
 F  B-  T C &
 F  ~   T CO T   T 	 CPROGCODE %  

 ! ) T  C	 CPROGCODE   PROGRAMS   C wellinv    %  
l %=U     
 F 	 B     %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA	 CPROGCODE RIOPEN RIEND RIUPDATE RIREUSEJ    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C	 CIDPUMPER_ T   T 	 CIDPUMPER T   %   T C wells  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T 	 CIDPUMPER %  
 ! ( T  C	 CIDPUMPER   PUMPERS   C wells    %  
 %=     
 F 	 B     %=0     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA	 CIDPUMPER RIOPEN RIEND RIUPDATE RIREUSEC    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CREVKEY_ T   T  CREVKEY T   %  
 T C income  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CREVKEY %  
 ! % T  C CREVKEY   REVSRC   C income    %  
 %=     
 F 	 B     %=)     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CREVKEY RIOPEN RIEND RIUPDATE RIREUSEO    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CTABLE_ T   T  CTABLE T   %   T C wells  %   %=  - 
 F  B-  T C &
 F  ~C f  T CO T C f T  UPPER(CTABLE)+ T  C CTABLEC \ sevtax  %  
 !   C wells    %  
 %=     
 F 	 B     %=5     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CTABLE RIOPEN RIEND RIUPDATE RIREUSEI    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CTAXCODE_ T   T  CTAXCODE T   %   T C expcat  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CTAXCODE %  
 ! ( T  C CTAXCODE   TAXCODES   C expcat    %  
 %=     
 F 	 B     %=/     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CTAXCODE RIOPEN RIEND RIUPDATE RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO JC f(   T  UPPER(CVENDORID)$ T C expense	 cvendorid  %   %=  -  B-  T C & T  C  

 F  T CO T   T 	 CVENDORID %  
9 T C Delete restrict rule violated.       C expense    %  
 %=     
 F 	 B   
 F  T C& T CO JC f(   T  UPPER(CVENDORID)$ T C appmtdet vendorid  %   %=  -  B-  T C & T  C  

 F  T CO T   T 	 CVENDORID %  
<9 T C Delete restrict rule violated.       C appmtdet    %  
 %=     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA	 CVENDORID RIOPEN RIEND RIERROR RIREUSE    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO  T C UPPER(CVENDORID)_ T   T  UPPER(CVENDORID) T C f %  $ T C vendexp  %  ) %=  - 
 F  B-  T C &
 F  ~   T CO T   T 	 CVENDORID %  
 ! ' T  C	 CVENDORID   VENDOR   C vendexp    %  
  %=	     
 F 	 B    
 F  T C& T CO  T C UPPER(CVENDORID)_ T   T  UPPER(CVENDORID) T C f %  
 T C appurchh  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T 	 CVENDORID %  
~ ! ' T  C	 CVENDORID   VENDOR   C appurchh    %  
 %=     
 F 	 B    
 F  T C& T CO  T C UPPER(CVENDORID)_ T   T  UPPER(CVENDORID) T C f %   T C appurech  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T 	 CVENDORID %  
d ! ' T  C	 CVENDORID   VENDOR   C appurech    %  
 %=     
 F 	 B    
 F  T C& T CO  T C UPPER(CVENDORID)_ T   T  UPPER(CVENDORID) T C f %  	 T C glmaster  %   %=  - 
 F  B-  T C &
 F  ~  i	 T CO T   T  CID %  
D	 ! ! T  C CID   VENDOR   C glmaster    %  
	 %=	     
 F 	 B    
 F  T C& T CO  T C UPPER(CVENDORID)_ T   T  UPPER(CVENDORID) T C f %   T C checks  %  
 %=
  - 
 F  B-  T C &
 F  ~  A T CO T   T  CID %  
 ! ! T  C CID   VENDOR   C checks    %  
 %=     
 F 	 B    
 F  T C& T CO  T C UPPER(CVENDORID)_ T   T  UPPER(CVENDORID) T C f %   T C expense  %   %=t  - 
 F  B-  T C &
 F  ~  $ T CO T   T 	 CVENDORID %  
 ! ' T  C	 CVENDORID   VENDOR   C expense    %  
 %=i     
 F 	 B    
 F  T C& T CO  T C UPPER(CVENDORID)_ T   T  UPPER(CVENDORID) T C f %  j T C appmtdet  %  n %=Y  - 
 F  B-  T C &
 F  ~  	 T CO T   T 	 CVENDORID %  
 ! ' T  C	 CVENDORID   VENDOR   C appmtdet    %  
f %=O     
 F 	 B     %=     
 F 	 B   U   LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA	 CVENDORID RIOPEN RIEND RIUPDATE RIREUSE CID    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA            T CW T  a T CW
 F  T C& T CO J (   T  CWELLID$ T C	 leasewell cwellid  %   %=  -  B-  T C &
 F 	 E  ~+     	R T CO T   T  CWELLID T  C   C	 leasewell    %  
 %=     
 F 	 B    %=     
 F 	 B   U  LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCCHILDWKAREA LCPARENTWKAREA LLDELHEADERAREA LCSTARTAREA CWELLID RIOPEN RIEND RIDELETE RIREUSE4    T  a 5       5  ! J  (       J (   %= ' 5	 
         T C TALKv G2 T C DELETEDv T C EXACTv T C
 COMPATIBLEv GA G  G T	    T
    T C error T  ? 17 pnerror=rierror(ERROR(),message(),message(1),program()) %C gaErrors(1)b U <   7  T C G( APPDATA                T CW T  a T CW
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %   T C welltots  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CWELLID %  
 ! $ T  C CWELLID   WELLS   C welltots    %  
	 %=     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %   T C metersub  %   %=  - 
 F  B-  T C &
 F  ~  y T CO T   T  CWELLID %  
Q ! $ T  C CWELLID   WELLS   C metersub    %  
 %=     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %   T C deplfile  %   %=  - 
 F  B-  T C &
 F  ~  F T CO T   T  CWELLID %  
 ! $ T  C CWELLID   WELLS   C deplfile    %  
 %=     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  t	 T C appurecd  %  } %=h  - 
 F  B-  T C &
 F  ~  	 T CO T   T  CUNITNO %  
 ! $ T  C CUNITNO   WELLS   C appurecd    %  
p	 %=Y	     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  A T C glmaster  %  J
 %=5
  - 
 F  B-  T C &
 F  ~  
 T CO T   T  CUNITNO %  

 ! $ T  C CUNITNO   WELLS   C glmaster    %  
= %=&     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %   T C csrctdet  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CWELLID %  
 ! $ T  C CWELLID   WELLS   C csrctdet    %  

 %=     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %   T C form6  %   %=  - 
 F  B-  T C &
 F  ~  w T CO T   T  CWELLID %  
O ! $ T  C CWELLID   WELLS   C form6    %  
 %=     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %   T C workord  %   %=  - 
 F  B-  T C &
 F  ~  @ T CO T   T  CWELLID %  
 ! $ T  C CWELLID   WELLS   C workord    %  
 %=     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  k T C expense  %  u %=`  - 
 F  B-  T C &
 F  ~   T CO T   T  CWELLID %  
 ! $ T  C CWELLID   WELLS   C expense    %  
g %=P     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  6 T C expsusp  %  @ %=+  - 
 F  B-  T C &
 F  ~   T CO T   T  CWELLID %  
 ! $ T  C CWELLID   WELLS   C expsusp    %  
2 %=     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %   T C incsusp  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CWELLID %  
y ! $ T  C CWELLID   WELLS   C incsusp    %  
 %=     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %   T C susaudit  %   %=  - 
 F  B-  T C &
 F  ~  m T CO T   T  CWELLID %  
E ! $ T  C CWELLID   WELLS   C susaudit    %  
 %=     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %   T C glredet  %   %=  - 
 F  B-  T C &
 F  ~  9 T CO T   T  CUNITNO %  
 ! $ T  C CUNITNO   WELLS   C glredet    %  
 %=~     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  b T C afehdr  %  m %=X  - 
 F  B-  T C &
 F  ~   T CO T   T  CWELLID %  
 ! $ T  C CWELLID   WELLS   C afehdr    %  
^ %=G     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  / T C invtrans  %  8 %=#  - 
 F  B-  T C &
 F  ~   T CO T   T  CWELLID %  
 ! $ T  C CWELLID   WELLS   C invtrans    %  
+ %=     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %   T C income  %   %=  - 
 F  B-  T C &
 F  ~   T CO T   T  CWELLID %  
q ! $ T  C CWELLID   WELLS   C income    %  
 %=     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %    T C stmtnote  %   %=  - 
 F  B-  T C &
 F  ~  d  T CO T   T  CWELLID %  
<  ! $ T  C CWELLID   WELLS   C stmtnote    %  
  %=      
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  " T C roundtmp  %  ! %=!  - 
 F  B-  T C &
 F  ~  1" T CO T   T  CWELLID %  
	" ! $ T  C CWELLID   WELLS   C roundtmp    %  
" %=w"     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  _$ T C disbhist  %  h# %=S#  - 
 F  B-  T C &
 F  ~  # T CO T   T  CWELLID %  
# ! $ T  C CWELLID   WELLS   C disbhist    %  
[$ %=D$     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  ,& T C appurchd  %  5% %= %  - 
 F  B-  T C &
 F  ~  % T CO T   T  CUNITNO %  
% ! $ T  C CUNITNO   WELLS   C appurchd    %  
(& %=&     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  ' T C csdisdet  %  ' %=&  - 
 F  B-  T C &
 F  ~  ' T CO T   T  CUNITNO %  
p' ! $ T  C CUNITNO   WELLS   C csdisdet    %  
' %='     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  ) T C invdet  %  ( %=(  - 
 F  B-  T C &
 F  ~  c) T CO T   T  CUNITNO %  
;) ! $ T  C CUNITNO   WELLS   C invdet    %  
) %=)     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  + T C suspense  %  * %=*  - 
 F  B-  T C &
 F  ~  .+ T CO T   T  CWELLID %  
+ ! $ T  C CWELLID   WELLS   C suspense    %  
+ %=t+     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  ^- T C	 leasewell  %  f, %=Q,  - 
 F  B-  T C &
 F  ~  , T CO T   T  CWELLID %  
, ! $ T  C CWELLID   WELLS   C	 leasewell    %  
Z- %=C-     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  +/ T C wellhist  %  4. %=.  - 
 F  B-  T C &
 F  ~  . T CO T   T  CWELLID %  
. ! $ T  C CWELLID   WELLS   C wellhist    %  
'/ %=/     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  0 T C wellinv  %   0 %=/  - 
 F  B-  T C &
 F  ~  0 T CO T   T  CWELLID %  
n0 ! $ T  C CWELLID   WELLS   C wellinv    %  
0 %=0     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  2 T C	 meterdata  %  1 %=1  - 
 F  B-  T C &
 F  ~  c2 T CO T   T  CWELLID %  
;2 ! $ T  C CWELLID   WELLS   C	 meterdata    %  
2 %=2     
 F 	 B    
 F  T C& T CO T C CWELLID_ T   T  CWELLID T   %  4 T C prepayd  %  3 %=3  - 
 F  B-  T C &
 F  ~  04 T CO T   T  CWELLID %  
4 ! $ T  C CWELLID   WELLS   C prepayd    %  
4 %=u4     
 F 	 B     %=4     
 F 	 B   U   LLRETVAL PCPARENTDBF PNPARENTREC
 PCCHILDDBF
 PNCHILDREC
 PCPARENTID	 PCCHILDID PCPARENTEXPR PCCHILDEXPR PCRICURSORS PCRIWKAREAS PCRIOLDERROR PNERROR	 PCOLDDELE
 PCOLDEXACT	 PCOLDTALK PCOLDCOMPAT PCOLDDBC GAERRORS
 LCPARENTID LCOLDPARENTID LCCHILDWKAREA	 LCCHILDID LCOLDCHILDID LCPARENTWKAREA LCSTARTAREA CWELLID RIOPEN RIEND RIUPDATE RIREUSE CUNITNO     T  a %C C'
	 CS
9  T  -   %C'
|   %C	 BUFFERINGx 	 C   
 Z#CO T    	 B   U  LLRETVAL PNERROR         T a %C CS
@  T -   %C     5 3 T CCC tcCascadeParentb C     6f >    %C	 BUFFERING 	 C   
 Z#CO T   	 B  U  TCFIELDNAME
 TCNEWVALUE TCCASCADEPARENT LLRETVAL PCCASCADEPARENT PNERROR      ;      	 
         T a J  (    T CW %C    T C   V  (   %C    !   T CC  ]  T     ( h T C= C Error:   C  Alias:  @ Foxauditx T     T
 C H- C
 = 2 C'	 T  D C
 = 2 C'
	 T  I  3
 	  4
  T  I  2
 - T  U  %C   (CV~ %C z T C  !    T    T CCC DATABASE T	 C DATASESSIONv %C  T 
 oFoxAudit_   T C   %C J$ T CC& \  _LOG.DBF a T C  ' % FOXAUDITCC CLASSLIBvf
 G~( custom\FOXAUDIT  T - %C b O"
 7 : T  )  = CREATEOBJECT('FOXAUDIT',lcLogLocation) &lcCmd.
 T a  %C b O C 
	 % > T  - .cUserMsg1 = [Updated via interactive change] &lcCmd.
 A T  0 .LogUpdates(lcKey,lcTrigger,liDataSession,lcTag) IF NOT &lcCmd.Q T D FoxAudit  was unable to log the current transaction. The LogUpdates % T   method RETURNed .F. 1 C   FoxAudit 6.0 LogUpdates Problemx B-   T -  % 
 %C 0
  6 T  Transaction log table: C C C ] T  L The above transaction log table does not exist. Normally FoxAudit 6.0 would ' T   build the transaction ` T  O log for you.  The exception in this case is that an update was in progress and Z T  I Visual FoxPro does not allow the creation of a table inside of a trigger = T  , call. Use the FoxAudit 6.0 DBC Setup wizard [ T  J to create a transaction log table or create a FoxAudit 6.0 object outside # T   of a trigger call. j  H T ; FoxAudit 6.0 Problem. The oFoxAudit object was not created. $ C   FoxAudit 6.0 Errorx 
 B  U  TCKEY TCOBJECT TCLOGLOCATION TCTAG LLRETURNVALUE	 LCMSGTEXT LCDBC LCOBJECT LCLOGLOCATION LIDATASESSION LCFIELDSTATE LNAREA LCCMD LNKOUNT LNTAGS	 LCTRIGGER LLSTOREDPROC LCKEY LCTAG LOERROR LCALIAS MESSAGE I CUSTOM NormalizeString,     
 SoundsLike      RIDELETE     RIUPDATEw     rierror     riopen     riendZ     rireusek     __RI_DELETE_afehdr     __RI_UPDATE_afehdr     __RI_DELETE_appmthdr     __RI_UPDATE_appmthdr!     __RI_DELETE_appurchh&     __RI_UPDATE_appurchh+     __RI_DELETE_appurech1     __RI_UPDATE_appurech6     __RI_DELETE_coa<     __RI_UPDATE_coaC     __RI_DELETE_csdishdrW     __RI_UPDATE_csdishdr]     __RI_DELETE_csrcthdrb     __RI_UPDATE_csrcthdrh     __RI_UPDATE_custsm     __RI_DELETE_depositsy     __RI_UPDATE_deposits@~     __RI_UPDATE_disposal     __RI_DELETE_emps     __RI_UPDATE_emps     __RI_UPDATE_expcat     __RI_UPDATE_gasown     __RI_DELETE_glrecur     __RI_UPDATE_glrecur     __RI_UPDATE_groups{     __RI_UPDATE_investor     __RI_DELETE_invhdr     __RI_UPDATE_invhdrP     __RI_DELETE_invrech    __RI_UPDATE_invrech:    __RI_DELETE_items    __RI_UPDATE_itemsR    __RI_DELETE_land    __RI_UPDATE_landg#    __RI_DELETE_meterall.    __RI_UPDATE_meterall3    __RI_UPDATE_meters9    __RI_DELETE_proghsthD    __RI_UPDATE_proghsthJ    __RI_DELETE_programsO    __RI_UPDATE_programsV    __RI_UPDATE_pumpersc    __RI_UPDATE_revsrci    __RI_UPDATE_sevtaxPo    __RI_UPDATE_taxcodesu    __RI_DELETE_vendorz    __RI_UPDATE_vendor    __RI_DELETE_wells    __RI_UPDATE_wellsU    RIDELETE    RIUPDATEZ    FoxAudit   1 q 4 q 4 A A  "12Q !!A  A A qA  A A A 1A C3 q     A  A A A   2  q  A  1q 1 A A A   2 1 1A  1A  3  r qA A  A    R A   A  R1A  A A  3 q   Q  a A a A    A QA 1a A Aa A 1a A 1a A   a  A q 3  Rq 4 q   Q r1a aAa a a   Q q A 1 1A q q q q q       A A q A      A A q  A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       q A q A  q A   !  A A A QA q  A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       1! A q A      1 A   A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       a 1  A  q A   !  1 A A aA   A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       1! A q A      1 A   A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       a 1  A  q A   !  1 A A aA   A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       1! A q A      1 A   A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       a 1  A  q A   !  1 A A aA   A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       A! A q A  1   A A   A   A    A A q A  1   A A q  A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       q A  A  q A   !  A A A !A   A   A A    q A  A  q A   !  A A A !A   A   A A    q A q A  q A   !  A A A !A q  A   A A    q A  A  q A   !  A A A !A   A   A A    q A q A  q A   !  A A A !A q  A   A A    q A q A  q A   !  Q A A 1A q  A   A A    q A q A  q A   !  Q A A 1A q  A   A A    q A q A  q A   !  Q A A 1A q  A   A A    q A q A  q A   !  Q A A 1A q  A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       1! A q A      1 A   A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       a 1  A  q A   !  1 A A aA   A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       1! A q A      1 A   A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       a 1  A  q A   !  1 A A aA   A   A A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q         q A  q A   !  A A A AA q  A   A A       A  q A   !   A A A   A   A A       A  q A   !  A A A AA   A   A A      q A  q A   !   A A A q  A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       1! A q A      1 A   A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       a 1  A  q A   !  1 A A aA   A   A A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q        Q  A  q A   !  Q A A A   A   A A     Q a A  q A   !  Q A A A a  A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       1 A q A  1   1 A q  A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       a 1  A  q A   !   A A A   A   A A    a 1 q A  q A   !  1 A A !A q  A   A A    a 1  A  q A   !  1 A A !A   A   A A    a 1  A  q A   !  1 A A !A   A   A A    a 1 q A  q A   !   A A A q  A   A A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q        Q  A  q A   !  Q A A aA   A   A A     Q  A  q A   !  Q A A aA   A   A A     Q  A  q A   !  Q A A aA   A   A A     Q  A  q A   !  Q A A aA   A   A A     Q  A  q A   !  Q A A aA   A   A A     Q  A  q A   !  ! A A 1A   A   A A     Q  A  q A   !  Q A A aA   A   A A     Q q A  q A   !  Q A A aA q  A   A A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q        Q q A  q A   !  Q A A aA q  A   A A     Q q A  q A   !  Q A A aA q  A   A A     Q q A  q A   a  A A A q  A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       1 A q A      1 A   A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       a 1  A  q A   !  1 A A QA   A   A A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       a 1  A  q A   !  1 A A AA   A   A A    a 1 a A  q A   A   A A A a  A   A A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q        Q  A  q A   !  Q A A A   A   A A     Q q A  q A   !  A A A qA q  A   A A     Q q A  q A   !   A A 1A q  A   A A     Q  A  q A   !  Q A A A   A   A A     Q  A  q A   !  Q A A A   A   A A     Q  A  q A   !  Q A A A   A   A A     Q  A  q A   !  Q A A A   A   A A     Q  A  q A   !  Q A A A   A   A A     Q  A  q A   !  Q A A A   A   A A     Q  A  q A   !  Q A A A   A   A A     Q  A  q A   !  Q A A A   A   A A     Q  A  q A   !  Q A A A   A   A A     Q  A  q A   !  Q A A A   A   A A     Q  A  q A   !   A A 1A   A   A A     Q  A  q A   !   A A 1A   A   A A     Q  A  q A   !  Q A A A   A   A A     Q  A  q A   !  Q A A A   A   A A     Q  A  q A   !  A A A qA   A   A A     Q q A  q A   !  Q A A A q  A   A A     Q q A  q A   a  A A A q  A   A A     Q  A  q A   !  A A A qA   A   A A     Q  A  q A   !  Q A A A   A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       1 A q A      1 A q  A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       a 1 q A  q A   !  1 A A AA q  A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       1 A q A      1 A   A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       a 1  A  q A   !  1 A A QA   A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       A A q A  1   A A q  A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       q A q A  q A   !  A A A AA q  A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       QQ A q A      Q A   A   A    QQ A q A      Q A   A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q        Q  A  q A   !  Q A A AA   A   A A     Q  A  q A   !  Q A A AA   A   A A     Q  A  q A   !  Q A A AA   A   A A     Q a A  q A   A   A A A a  A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       1! A q A      1 A   A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       a 1  A  q A   !  1 A A aA   A   A A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q        Q  A  q A   !  Q A A aA   A   A A     Q  A  q A   !  Q A A aA   A   A A     Q  A  q A   !  Q A A aA   A   A A     Q a A  q A   A   A A A a  A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       1! A q A      1 A   A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       a 1  A  q A   !  1 A A aA   A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       aA A q A      a A   A   A    aQ A q A  1   a A   A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q        a  A  q A   !  a A A A   A   A A     a  A  q A   !  a A A A   A   A A     a  A  q A   !  a A A A   A   A A     a q A  q A   !  a A A A q  A   A A     a  A  q A   !  a A A A   A   A A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q        a a A  q A   !  a A A A a  A   A A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       q A q A  q A   !  A A A QA q  A   A A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       a 1 a A  q A   A   A A A a  A   A A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q        Q q A  q A   !  Q A A A q  A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       1A A q A  1   a A   A   A    1A A q A  1   a A   A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q          A  q A   !  a A A qA   A   A A       A  q A   !  a A A qA   A   A A       A  q A   !  a A A qA   A   A A       A  q A   !   A A A   A   A A      q A  q A   !   A A A q  A   A A       A  q A   !  a A A qA   A   A A       A  q A   !  a A A qA   A   A A  A   6 q   Q r1a aAa a a   Q q A 1 1A q q q q q       AA A q A      A A   A   A  A   5 r   Q r1a aAa a a   Q q A 1 1A q q q q q q q       q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A a A  q A   !  A A A AA a  A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A q A  q A   !  A A A AA q  A   A A    q A  A  q A   !  A A A AA   A   A A    q A q A  q A   !  A A A AA q  A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A q A  q A   !  A A A AA q  A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A    q A  A  q A   !  A A A AA   A   A A  A   6 q     A  A B A   2  q  A  1q 1 A B A   < 1     1r1A A A q  A    A     " A  q A A A   A    A  A  A xA  A   A   A aQ A   A  q aq1 q A BA  6                                   7  	   C   M    \   S       m   f             -          *                    -  "(       B(  ,3  H  h  N3  E<      g<  VG      xG  oP  E  I  P  [      [  d      d  o  7  3  o  {      {  i    	      q  Q                      c  ;              ~  @             "        N   ,   /	  3, R 	  |
  R f %    'f o   ]  :o y     z  i  #      h    0      }        I  	  "       z     +   {  , 78 g    U8 _O     O xX     X Qc   6  qc z 9    z    ;    J                    #    J  t                P  {  -              7  	     [     L m  ,  a     )                    